<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sweeney Di&#39;s Blog</title>
  
  <subtitle>I took the one less traveled by and that has made all the difference</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/December1900/December1900.github.io.git/"/>
  <updated>2017-12-01T16:30:19.195Z</updated>
  <id>https://github.com/December1900/December1900.github.io.git/</id>
  
  <author>
    <name>Sweeney Di</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式读书笔记-代理模式</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2017/11/27/Proxy%20Pattern%20Note/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2017/11/27/Proxy Pattern Note/</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2017-12-01T16:30:19.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>代理模式：给某一个对象提供一个代理，并由代理对象控制原对象的引用。代理模式是一种对象结构型模式。<a id="more"></a></p></blockquote><p>代理模式根据其目的和实现不同可分为很多种类，其中常用的几种代理模式如下：</p><ol><li><strong>远程代理</strong>：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。</li><li><strong>虚拟代理</strong>：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong>保护代理</strong>：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong>缓冲代理</strong>：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong>智能引用代理</strong>：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来。</li></ol><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>当客户端对象需要访问远程主机中的对象时，可以使用远程代理</li></ol><h1 id="代理模式概述"><a href="#代理模式概述" class="headerlink" title="代理模式概述"></a>代理模式概述</h1><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><p><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:dp:proxy.png" alt="Proxy Pattern"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>通常情况下，每一个代理类编译之后都会生成一个class文件，代理类所实现的接口和所代理的方法都被固定，这种代理被称为静态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象主题角色</span></div><div class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">Subject</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">(String message)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//真实主题角色</span></div><div class="line"><span class="function"><span class="keyword">public</span> class <span class="title">RealSubject</span><span class="params">()</span> implements Subject</span>&#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String message)</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"send the "</span> + messagejkj);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//代理主题角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">//维持一个对真实主题对象的引用</span></div><div class="line">  <span class="keyword">private</span> RealSubject realSubject = <span class="keyword">new</span> RealSubject();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRequest</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"prepare the request"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRequest</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"send the request success"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(String message)</span></span>&#123;</div><div class="line">    preRequest();</div><div class="line">    realSubject.request(message);</div><div class="line">    postRequest();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Subject subject = <span class="keyword">new</span> Proxy();</div><div class="line">    subject.request(<span class="string">"proxy pattern"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在传统的代理模式中，客户端通过Proxy类调用RealSubject类的reuqest()方法，同时还可以在代理类中封装其他方法。如果按照这种方法使用代理模式，那么代理类和真实主题类都应该是事先已经存在的，代理类的接口和说代理方法都已明确指定，如果需要为不同的真实主题类提供代理类或者代理一个真实主题类中的不同方法，都需要增加新的代理类，这将导致系统中的类个数急剧增加。</p><p><strong>动态代理可以让系统根据实际需求来动态创建代理类，让同一个代理类能够处理多个不同的真实主题类，而且可以代理不同的方法。</strong></p><p>Java实现动态代理需要用到位于java.lang.reflect包中的一些类。</p><ol><li><strong>Proxy</strong><br><code>Proxy</code>类提供了用于创建动态代理类和胜利对象的方法，它是所创建的动态代理类的父类，最常用的方法：</li></ol><ul><li><code>public static Class&lt;?&gt; getProxyClass(Classloader loader, Class&lt;?&gt;...interfaces)</code></li><li><code>public static Object newProxyInstance(ClassLoader loader, Class[]&lt;?&gt; interfaces, InvocationHandler h)</code></li></ul><ol><li><strong>InvocationHanlder</strong><br><code>InvocationHandler</code>接口是代理处理程序类的实现接口，该接口作为代理实例的调用者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者</li></ol><ul><li><code>public Object invoke(Object proxy, Method method, Object[] args)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//抽象主题角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractUserDAO</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">findUserById</span><span class="params">(String userId)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//抽象主题角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractDocumentDAO</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">deleteDocumentById</span><span class="params">(String documentId)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//真实主题角色</span></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAO</span> <span class="keyword">implements</span> <span class="title">AbstractUserDAO</span></span>&#123;</div><div class="line">   </div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findUserById</span><span class="params">(String userId)</span></span>&#123;</div><div class="line">     <span class="keyword">if</span>(userId.equalsIgnoreCase(<span class="string">"Sam"</span>))&#123;</div><div class="line">       System.out.println(<span class="string">"select ID ="</span> + userId + <span class="string">"information successfully!"</span>)</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">       System.out.println(<span class="string">"select ID ="</span>+ userId + <span class="string">"information unsuccessfully!"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">   &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//真实主题角色</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentDAO</span> <span class="keyword">implements</span> <span class="title">AbstractDocumentDAO</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteDocumentById</span><span class="params">(String documentId)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(userId.equalsIgnoreCase(<span class="string">"Sam"</span>)&#123;</div><div class="line">      System.out.println(<span class="string">"delete ID ="</span> + documentId + <span class="string">" document successfully!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      System.out.println(<span class="string">"delete ID ="</span> + documentId + <span class="string">" document unsuccessfully!"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//自定义请求处理类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAOLogHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> Object object;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DAOLogHandler</span><span class="params">(Object object)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.object = object;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">    beforeInvoke();</div><div class="line">    Object result = method.invoke(object,args);</div><div class="line">    afterInvoke();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"invoke time="</span> + System.currentTimeMillis());</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterInvoke</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"invoke finish!"</span>)</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    InvoationHandler handler = <span class="keyword">null</span>;</div><div class="line">    </div><div class="line">    AbstractUserDAO userDAO = <span class="keyword">new</span> UserDAO();</div><div class="line">    handler = <span class="keyword">new</span> DAOLogHandler(userDAO);</div><div class="line">    AbstactUserDAO proxy = <span class="keyword">null</span>;</div><div class="line">    proxy = (AbstractUserDAO) proxy.newInstance(AbstractUserDAO.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;AbstractUserDAO.class&#125;,handler);</div><div class="line">    proxy.findUserById(<span class="string">"Sam"</span>);</div><div class="line">    </div><div class="line">    System.out.println(<span class="string">"-------------------"</span>);</div><div class="line">    </div><div class="line">    AbstractDocumentDAO documentDAO = <span class="keyword">new</span> DocumentDAO();</div><div class="line">    handler = <span class="keyword">new</span> DAOLogHandler(documentDAO);</div><div class="line">    AbstractDocument proxy_doc = <span class="keyword">null</span>;</div><div class="line">    proxy_doc = (AbstractDocumentDAO) proxy_doc.newInstance(AbstractDocument.class.getClassLoader(),<span class="keyword">new</span> Class[]&#123;AbstractDocumentDAO.class&#125;,handler);</div><div class="line">    proxy_doc.deleteDocumentById(<span class="string">"Sam"</span>);</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="代理模式总结"><a href="#代理模式总结" class="headerlink" title="代理模式总结"></a>代理模式总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;代理模式：给某一个对象提供一个代理，并由代理对象控制原对象的引用。代理模式是一种对象结构型模式。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RxJava2.x 整理</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2017/11/03/RxJava%202.x/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2017/11/03/RxJava 2.x/</id>
    <published>2017-11-02T16:00:00.000Z</published>
    <updated>2017-12-01T15:58:18.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于RxJava"><a href="#关于RxJava" class="headerlink" title="关于RxJava"></a>关于RxJava</h1><p>RxJava属于响应式编程，是一种基于异步数据流的编程方式。<br>响应式编程的一个关键概念是事件。因为事件是唯一合适的方式将我们的现实世界映射到软件中，对此我们做出响应。<a id="more"></a></p><p>RxJava到底是什么 — 异步。<br>RxJava好在哪里 — 简洁。</p><p>响应式的RxJava通过链式的逻辑简洁能够呈现出最简洁但不失优雅的异步代码，更重要的是随着逻辑越来越复杂，它依然可以保持简洁。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><strong>Observable：被观察者，它决定什么时候触发事件以及触发怎么样的事件</strong><br><strong>Observer：观察者，它决定事件触发的时候将有什么样的行为</strong></p><p>当发生事件时候，Observable 通过 subscribe() 订阅 Observer，这就是观察者模式</p><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx46dspqj20gn04qaad.jpg" alt=""></p><p>对比一个实例更容易理解</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx42h1wgj20fz03rglt.jpg" alt=""><br>按照观察者模式来理解（Button -&gt; 被观察者，OnClikcListener -&gt; 观察者，setOnClickListener -&gt; 订阅，onClick -&gt; 事件）</p><p>因此RxJava四个基本概念分别为：<code>Observable</code>(可观察者，即被观察者)、 <code>Observer</code>(观察者)、 <code>subscribe</code> (订阅)、事件。<code>Observable</code> 和 <code>Observer</code> 通过 subscribe() 方法实现订阅关系，从而 <code>Observable</code> 可以在需要的时候发出事件来通知<code>Observer</code>。</p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>相比于1.x，2.x增加新特性并且依赖了于四个基本接口</p><ul><li>Publisher</li><li>Subscriber</li><li>Subscription</li><li>Processor</li></ul><p>Publisher发送事件，Subscriber接受和处理事件。在 RxJava 2.x 中，Observable 用于订阅 Observer，不再支持背压（1.x 中可以使用背压策略），而 Flowable 用于订阅 Subscriber ， 是支持背压的。</p><blockquote><p>背压：背压是指在异步场景中，被观察者发送速度远快于观察者处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略</p></blockquote><p>因此2.x最大的改动就是将 Observable 拆分为 Observable 和 Flowable。</p><p>同时出现了两种观察者模式。</p><p><img src="http://upload-images.jianshu.io/upload_images/3994917-21e4dcc1b5e3196a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="创建Observer"><a href="#创建Observer" class="headerlink" title="创建Observer"></a>创建Observer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observer&lt;Integer&gt; observer = <span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</div><div class="line">    Disposable mDisposable;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</div><div class="line">        mDisposable = d;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (integer == <span class="number">2</span>) &#123;</div><div class="line">            mDisposable.dispose();</div><div class="line">        &#125;</div><div class="line">        Log.d(TAG, <span class="string">"onNext : value : "</span> + integer + <span class="string">"\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">        Log.d(TAG, <span class="string">"onComplete"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><code>onSubscribe()</code>回调方法传递参数为<code>Disposable</code>，<code>Disposable</code>相当于 RxJava 1.x 中的 <code>Subscription</code>， 用于解除订阅。</p><p>同时需要注意的是，<code>onComplete()</code>和<code>onError()</code>方法是互斥的，在队列中调用其中一个，就不应该再调用另一个。</p><h3 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Log.d(TAG, <span class="string">"Observable emit 1\n"</span>);</div><div class="line">        e.onNext(<span class="number">1</span>);</div><div class="line">        Log.d(TAG, <span class="string">"Observable emit 2\n"</span>);</div><div class="line">        e.onNext(<span class="number">2</span>);</div><div class="line">        Log.d(TAG, <span class="string">"Observable emit 3\n"</span>);</div><div class="line">        e.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>创建Observable时，回调<code>ObservableEmitter</code>，被调用两次<code>onNext()</code>和一次<code>onComplete</code>并直接throws Exception。</p><p>除了<code>create()</code>方法之外，RxJava 2.x 还提供一些方法来快捷创建队列。</p><p>下列方法最终效果和使用create()方法一样。</p><p><strong>just()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure></p><p><strong>fromArray()</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</div><div class="line">Observable observable = Observable.fromArray(nums);</div></pre></td></tr></table></figure></p><h3 id="订阅Subscribe"><a href="#订阅Subscribe" class="headerlink" title="订阅Subscribe"></a>订阅Subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter&lt;Integer&gt; e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            Log.d(TAG, <span class="string">"Observable emit 1\n"</span>);</div><div class="line">            e.onNext(<span class="number">1</span>);</div><div class="line">            Log.d(TAG, <span class="string">"Observable emit 2\n"</span>);</div><div class="line">            e.onNext(<span class="number">2</span>);</div><div class="line">            Log.d(TAG, <span class="string">"Observable emit 3\n"</span>);</div><div class="line">            e.onComplete();</div><div class="line">        &#125;</div><div class="line">    &#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</div><div class="line">        Disposable mDisposable;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</div><div class="line">            mDisposable = d;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (integer == <span class="number">2</span>) &#123;</div><div class="line">                mDisposable.dispose();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            Log.d(TAG, <span class="string">"onNext : integer : "</span> + integer + <span class="string">"\n"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line">            Log.d(TAG, <span class="string">"onComplete"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除了 <code>subscribe(Observer)</code>和<code>subscribe(Subscriber)</code>，<code>subscribe()</code>还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。</p><p><code>Consumer</code>是一个接口，只有一个单参数无返回值的accept()方法，由于<code>onNext(T obj)</code>和 <code>onError(Throwable e)</code>也是单参数无返回值的，因此 <code>Consumer</code>可以将 <code>onNext(obj)</code>和 <code>onError(e)</code>打包起来传入 subscribe() 以实现不完整定义的回调。</p><p><code>BiConsumer</code>则是接受两个参数。</p><p>类比RxJava 1.x</p><p><code>Consumer</code> -&gt; <code>Action1</code></p><p><code>BiConsumer</code> -&gt; <code>Action2</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">            .subscribe(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    Log.d(TAG, <span class="string">"accept : integer :"</span> + integer + <span class="string">"\n"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;, <span class="keyword">new</span> Consumer&lt;Throwable&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    Log.d(TAG, throwable.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="变换的原理lift"><a href="#变换的原理lift" class="headerlink" title="变换的原理lift()"></a>变换的原理lift()</h2><p>lift()核心代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</div><div class="line">            Subscriber newSubscriber = operator.call(subscriber);</div><div class="line">            newSubscriber.onStart();</div><div class="line">            onSubscribe.call(newSubscriber);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>好玩的是 lift() 生成新的 Observable 并返回，而且创建新 Observable 所用参数 OnSubscribe 的回调方法 call() 的实现和Observable.subscribe() 其实是一样的。在lift()创建了一个 Observable 后，加上之前的原始 Observable，其实就会有两个 Observable。</p><p>类比过来 lift() 有些像一种代理机制，拦截事件和实现事件序列的变换。</p><p>这句话概括的简洁明了</p><blockquote><p>在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p></blockquote><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcrna27j20h40d1q4f.jpg" alt=""></p><h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><p>既然是异步，关键在于线程的切换，RxJava使用 subscribeOn() 和 observeOn() 来轻松进行线程控制。</p><p>RxJava内置线程供选择</p><ul><li>Schedulers.io()  io操作的线程, 通常用于网络,读写文件等io密集型的操作；</li><li>Schedulers.computation() CPU密集型计算的线程，即不会被 I/O 等操作限制性能的操作；</li><li>Schedulers.newThread() 创建新线程；</li><li>AndroidSchedulers.mainThread() 代表Android的主线程；</li></ul><p><strong>subscribeOn()：指定 subscribe() 所发生的线程，即Observable.onSubscribe被激活时所处的线程，是事件的产生线程。</strong></p><p><strong>observeOn()：指定 subscriber 所运行的线程，是事件的消费线程，我更愿意理解为事件的回调和呈现线程。</strong></p><blockquote><p>后台线程取数据，主线程显示</p></blockquote><p><code>subscribeOn()</code> 和 <code>observeOn()</code>的内部实现也是用的 <code>lift()</code>，也就是说线程控制的原理主要也是lift ()。</p><p>不同的是 subscribeOn() 的线程切换发生在内建的 OnSubscribe 中，在通知上一级 OnSubscribe 时，事件还没有由上一级的 OnSubscribe 发送到Subscriber，所以 <code>subscribeOn()</code>可以从一开始最开端就影响后续的切换。</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcynbsuj20ha0d7wg2.jpg" alt=""></p><p>但是 <code>observeOn()</code> 不一样，它的线程切换发生在内建的<br> Subscriber 发送事件给下一级的 Subscriber时，所以<code>observeOn()</code>是控制后面的线程，observeOn() 指定的是它之后的操作所在的线程。</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxd05lttj20hj0cyabl.jpg" alt=""></p><p>这样也就很好理解如果有多次切换线程的需求, <code>observeOn()</code>可以多次调用，但是只有第一个 <code>subscribeOn()</code> 起作用，因为通知过程中线程就被第一个<code>subscribeOn()</code>截断了。</p><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxd1vl7xj20hd0hzq6e.jpg" alt=""></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><a href="https://github.com/December1900/RxJava2Samples-Android">Mytraining for RxJava2</a></p><h2 id="留坑"><a href="#留坑" class="headerlink" title="留坑"></a>留坑</h2><p><code>doOnNext()</code>，<code>doOnSubscribeOn()</code>分析</p><hr><h1 id="RxJava-1-x-VS-RxJava-2-x"><a href="#RxJava-1-x-VS-RxJava-2-x" class="headerlink" title="RxJava 1.x VS RxJava 2.x"></a>RxJava 1.x VS RxJava 2.x</h1><table><thead><tr><th>RxJava 1.x</th><th>RxJava 2.x</th></tr></thead><tbody><tr><td>About <code>backpressure</code> <img src="http://on-img.com/chart_image/59955604e4b0a6812c100916.png" alt=""></td><td>About <code>backpressure</code> <img src="http://on-img.com/chart_image/5995587ae4b0b83fa260c4e9.png" alt=""></td></tr><tr><td>when create Observable, callback <code>Observable.onSubscribe()</code></td><td>when create Observable, callback <code>ObservableEmitter&lt;&gt;</code> and directly <code>throws Exception</code></td></tr><tr><td>when create Observer, callback <code>onNext(),onError(),onCompleted()</code>, use <code>Subscription</code></td><td>when create Observer, callback <code>onNext(),onError(),onComplete(),onSubscribe()</code>, use <code>Disposable</code></td></tr><tr><td>To simplify subscribe, <code>Fun1, Fun2, Action1，Action2</code></td><td>To simplify subscribe, <code>Function, BiFunction, Consumer, BiConsumer</code></td></tr></tbody></table><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h1><p><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">RxJava-Doc</a></p><p><a href="http://gank.io/post/560e15be2dca930e00da1083#toc_2" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a></p><p><a href="http://www.jianshu.com/p/0cd258eecf60" target="_blank" rel="external">这可能是最好的RxJava 2.x 教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于RxJava&quot;&gt;&lt;a href=&quot;#关于RxJava&quot; class=&quot;headerlink&quot; title=&quot;关于RxJava&quot;&gt;&lt;/a&gt;关于RxJava&lt;/h1&gt;&lt;p&gt;RxJava属于响应式编程，是一种基于异步数据流的编程方式。&lt;br&gt;响应式编程的一个关键概念是事件。因为事件是唯一合适的方式将我们的现实世界映射到软件中，对此我们做出响应。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式读书笔记-单例模式</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2017/10/27/Sinlgeton%20Pattern%20Note/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2017/10/27/Sinlgeton Pattern Note/</id>
    <published>2017-10-26T16:00:00.000Z</published>
    <updated>2017-12-01T12:40:48.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>单例模式：确保某一个类只有一个实例，且只能自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。<a id="more"></a></p></blockquote><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>系统只需要一个实例对象。例如，系统要求提供一个唯一的序列号生成器或者资源管理器，或者需要考虑资源消耗太大只允许创建一个状态（Windows进程管理器无论点击多少次始终只能弹出一个窗口，因为如果多个窗口弹出意味着在某一瞬间系统资源使用情况和进程，服务等信息存在多个状态）。</li><li>客户端调用类的单个实例只允许一个公共访问类。</li></ol><h1 id="单例模式概述"><a href="#单例模式概述" class="headerlink" title="单例模式概述"></a>单例模式概述</h1><p>单例类有很多实现方式，但是基本共同要点在于</p><h2 id="构建私有构造函数"><a href="#构建私有构造函数" class="headerlink" title="构建私有构造函数"></a><strong>构建私有构造函数</strong></h2><p>原因在于为了确保单例实例的唯一性，需要禁止类的外部直接用new来创建对象，因此需要将构造函数的可见性改为private</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div></pre></td></tr></table></figure><h2 id="定义静态Sinleton类型的私有成员变量"><a href="#定义静态Sinleton类型的私有成员变量" class="headerlink" title="定义静态Sinleton类型的私有成员变量"></a><strong>定义静态Sinleton类型的私有成员变量</strong></h2><ul><li>类的外部不能使用new来创建对象，但是外部能访问这个唯一实例，同时内部能创建保存这个唯一实例。</li><li>为什么成员变量需要定义为静态？因为提供给外部的静态方法不能访问非静态变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton single = <span class="keyword">null</span>;</div></pre></td></tr></table></figure><h2 id="定义一个公有的静态方法"><a href="#定义一个公有的静态方法" class="headerlink" title="定义一个公有的静态方法"></a><strong>定义一个公有的静态方法</strong></h2><p>提供给外界使用并实例化成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">if</span> (sinlge == <span class="keyword">null</span>)&#123;</div><div class="line">       single = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> tm;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此最简单经典的单例模式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton single = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      single = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p> 这是最经典实现方式，结合项目使用情况衍生出更多的实现方式</p><ul><li>Eager Singleton</li><li>Lazy and Thread safe Singleton</li><li>Bill Pugh Singleton</li><li>Enum Singleton</li></ul><hr><h2 id="饿汉单例"><a href="#饿汉单例" class="headerlink" title="饿汉单例"></a>饿汉单例</h2><p>结构图如下<br><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:dp:eager.png" alt="EagerSingleton"><br>由于在定义静态变量时实例化单例类，因此在类加载的时候就已经创建了单例对象，可确保单例对象的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerSingleton single = <span class="keyword">new</span> EagerSingleton();</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">EagerSinlgeton</span><span class="params">()</span></span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="懒汉单例与线程安全"><a href="#懒汉单例与线程安全" class="headerlink" title="懒汉单例与线程安全"></a>懒汉单例与线程安全</h2><p>结构图如下<br><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:dp:lazy.png" alt="LazySingleton"><br>可以看到懒汉单例在第一次调用getInstance()时实例化，在类加载时并不自行实例化，这种技术又称为「<strong>延迟加载（Lazy Load)</strong>」技术，即需要的时候再加载实例。为了避免多个线程同时调用getInstance()方法，可以使用synchronized关键字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton single = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      single = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样虽然解决了线程安全问题，但是每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。综合考虑，不用对整个getInstacne()进行锁定，只需锁定<code>single = new Singleton();</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton sinlge = <span class="keyword">null</span>;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazySinlgeton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">//the fisrt</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstacne</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</div><div class="line">        single = <span class="keyword">new</span> LazySinleton();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125; </div><div class="line">  </div><div class="line">  <span class="comment">//the second</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">synchronized</span>(LazySingleton.class)&#123;</div><div class="line">        <span class="keyword">if</span> (single == <span class="keyword">null</span>)&#123;</div><div class="line">          single = <span class="keyword">new</span> Singleton();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> single;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第二种比第一种方法多了一层<code>if (single == null)</code>判断，为什么需要这层判断？不加可不可以?</p><p>答案是不行。</p><p><strong>如果使用第一种方法来创建单例对象,还是会存在单例对象不唯一。</strong></p><p>因为假如A线程和B线程在同一时间调用getInstance()方法，此时均为null值，均能通过<code>single == nulli</code>判断。此时A线程进入synchronized锁定的代码模块执行实例创建，B线程处于排队等待状态，必须等待A线程执行完才能进入synchronized锁定代码模块。但当A线程执行完毕后，B线程并不知道实例已经创建，会再次创建实例导致产生多个实例对象，依然无法保证唯一的单例对象，因此需要再加入一层判断，这种方式称为「<strong>双重检查锁定（Double-Check Locking)</strong> 」</p><hr><p>但是在JDK1.5之前依然存在DCL失效问题。</p><p><code>single = new Singleton()</code>语句，这里看起来是一段代码，但实际上它并不是一个原子操作，这句代码最终会被编译成多条汇编指令，大致做了3件事情：</p><ol><li>给Singleton的实例分配内存</li><li>调用Singletion()的构造函数，初始化成员字段</li><li>将single对象指向分配的内存空间（此时single就不是null了）</li></ol><hr><p><strong>但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JVM中Cache，寄存器到主内存回写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序有可能是1-2-3，也有可能是1-3-2。如果是后者，并在3执行完毕、2未执行之前，被切换到B线程，这时候single因为已经在线程A内执行过了第三点，single已经是非空了，所以，线程B直接取走single，再使用就会出错，这就是DCL失效问题</strong></p><p>在JDK1.5之后，官方注意到这种问题，调整了JVM，具体化了volatile关键字，因此在1.5之后的版本，将single的定义为<code>private volatile static Singleton single = null</code>就可以保证single对象每次都是从主存中读取，但同时volatile关键字会屏蔽JVM所做的一些代码优化，可能会导致系统运行效率降低。</p><h2 id="Bill-Pugh-Singleton"><a href="#Bill-Pugh-Singleton" class="headerlink" title="Bill Pugh Singleton"></a>Bill Pugh Singleton</h2><blockquote><p>Prior to Java 5, java memory model had a lot of issues and above approaches used to fail in certain scenarios where too many threads try to get the instance of the Singleton class simultaneously. So Bill Pugh came up with a different approach to create the Singleton class using a inner static helper class. The Bill Pugh Singleton implementation goes like this;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span></span>&#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> BillPughSingleton instacne = <span class="keyword">new</span> BillPughSingleton();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> SingletonHelper.instance;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于静态单例对象没有作为BillPushSingleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SinlgetonHelper，内部类中的static变量instance会首先被初始化,由JVM来保证其线程安全，确保该成员变量只能初始化一次。</p><p>可是为什么这样就是线程安全的呢？很多文章和书籍都没有解释清楚都是一笔带过，JVM保证线程安全。</p><p>首先要知道的是<strong>静态变量只会初始化一次当类加载时</strong>。</p><p>其次是<strong>Java是多线程编程，初始化类或者接口时需要很精细的同步操作，因为同一时间可能有很多其他的线程尝试去初始化同样的类或接口</strong></p><blockquote><p>For each class or interface C, there is a unique initialization lock LC. The mapping from C to LC is left to the discretion of the Java Virtual Machine implementation.</p></blockquote><p>首先需要明确的是当getInstance()调用时才会加载SingletonHelper类，<br>而加载SingletonHelper类时会执行<code>private final static Singleton instance = new Singleton();</code>生成Singleton实例</p><p>简单来说，假如当两个线程尝试去初始化<code>getInstance()</code>时，就会去加载SingletonHepler类，这时需要LC锁的第一个线程才是实际上去初始化<code>getInstance()</code>的线程能加载SingletonHelper类的线程，因为<code>instance</code>是静态初始化，Java保证它只能被初始化一次。而当其他线程再进入<code>getInstance()</code>时，系统加载执行早已结束，保证了线程安全。</p><p>贴上两个摘要便于理解</p><ul><li><p><strong>Java Concurrency in Practice</strong></p><blockquote><p>The lazy initialization holder class idiom uses a class whose only purpose is to initialize the Resource. The JVM defers initializing the ResourceHolder class until it is actually used [JLS 12.4.1], and because the Resource is initialized with a static initializer, no additional synchronization is needed. The first call to getresource by any thread causes ResourceHolder to be loaded and initialized, at which time the initialization of the Resource happens through the static initializer.</p></blockquote></li><li><p><strong>Static initialization</strong></p><blockquote><p>Static initializers are run by the JVM at class initialization time, after class loading but before the class is used by any thread. Because the JVM acquires a lock during initialization [JLS 12.4.2] and this lock is acquired by each thread at least once to ensure that the class has been loaded, memory writes made during static initialization are automatically visible to all threads. Thus statically initialized objects require no explicit synchronization either during construction or when being referenced.</p></blockquote></li></ul><h2 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</div><div class="line">  INSTANCE;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Sinlgeton</span><span class="params">()</span></span>&#123;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWorks</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//do something here</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//If you then added another class with a main() method like</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">  Sinlgeton.INSTANCE.doWorks();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先要明确的是枚举是一种特殊的类</p><p>因此上文的枚举声明实际上可以类比为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSATNCE = <span class="keyword">new</span> Singleton();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当首次去调用INSTANCE时，Singleton类会被JVM加载并初始化，同时初始化静态变量的过程只发生一次，实现了延迟加载（lazily）。</p><p>其次枚举单例能够自行处理序列化，传统的单例一旦实现序列化接口将不能保证实例的唯一性，因为readObject()方法总是能像构造器那样返回一个新的实例。但是可以通过readResolve()方法避免这种情况发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//readResolve to prevent another instance of Singleton</span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">return</span> INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但实际上会更复杂运用在自己的单例类里，但是使用枚举类型，JVM来保证序列化。</p><p>最后就是创建枚举实例默认是线程安全的（恩不需要解释就是默认）以及简单易写相比于上面几种单例。</p><h2 id="VS"><a href="#VS" class="headerlink" title="VS"></a>VS</h2><table><thead><tr><th>Implementation</th><th>Advantage</th><th>Disadvantage</th></tr></thead><tbody><tr><td>Eager Sinlgeton</td><td>1.无需考虑多线程访问问题，可以确保实例的唯一性 2.保持较高的系统性能</td><td>类加载时就创建对象，不管将来用不用，始终占据内存，资源利用效率低</td></tr><tr><td>Lazy and Thread safe Singleton</td><td>实现延迟加载，无须一直占用系统资源</td><td>线程安全控制繁琐，而且系统性能受影响</td></tr><tr><td>Bill Pugh Singleton</td><td>实现延迟加载，又可以保证线程安全，不影响系统性能</td><td>与编程语言本身特性相关，很多面向对象语言不支持</td></tr><tr><td>Enum Singleton</td><td>实现延迟加载，又可以保证线程安全，不影响系统性能，同时支持序列化，简答易写</td><td>扩展性差</td></tr></tbody></table><h1 id="单例模式总结"><a href="#单例模式总结" class="headerlink" title="单例模式总结"></a>单例模式总结</h1><h2 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h2><ol><li>单例模式提供对唯一实例的受控访问，严格控制怎么以及何时访问唯一实例。</li><li>保证只存在唯一实例，节约系统资源。</li><li>允许可变数目的实例。</li></ol><h2 id="主要缺点"><a href="#主要缺点" class="headerlink" title="主要缺点"></a>主要缺点</h2><ol><li>单例模式中缺少抽象层，因此单例类的扩展性很差。</li><li>单例类的职责过重，在一定程度上违背了单一职责原则。单例类既提供了业务方法，也提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。</li><li>如今很多面向对象语言都提供自动垃圾回收技术，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁回收资源，下次利用时需要重新实例化。</li></ol><h1 id="留坑"><a href="#留坑" class="headerlink" title="留坑"></a>留坑</h1><p>留个volatile的坑后面来填~</p><h1 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h1><p><a href="https://stackoverflow.com/questions/46542017/java-singleton-with-an-inner-class-what-guarantees-thread-safety/46542569" target="_blank" rel="external">Java Singleton with an inner class - what guarantees thread safety?</a></p><p><a href="https://stackoverflow.com/questions/26285520/implementing-singleton-with-an-enum-in-java" target="_blank" rel="external">Implementing Singleton with an Enum</a></p><p><a href="https://stackoverflow.com/questions/2423622/volatile-vs-static-in-java" target="_blank" rel="external">Volatile Vs Static</a></p><p><a href="http://tutorials.jenkov.com/java-concurrency/volatile.html" target="_blank" rel="external">Java Volatile Keyword</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;单例模式：确保某一个类只有一个实例，且只能自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
    
    </summary>
    
      <category term="Java" scheme="https://github.com/December1900/December1900.github.io.git/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Fragment不完全解析（一）</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2017/05/14/Fragment-1/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2017/05/14/Fragment-1/</id>
    <published>2017-05-13T16:00:00.000Z</published>
    <updated>2017-12-01T12:38:15.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Fragment是在Android 3.0 (API level 11)开始引入的,它能让你的app在现有基础上性能大幅度提高，并且占用内存降低，同样的界面Activity占用内存比Fragment要多，响应速度Fragment比Activty在中低端手机上快了很多，甚至能达到好几倍,同时给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持.<a id="more"></a></p></blockquote><hr><h1 id="一、Fragment的生命周期"><a href="#一、Fragment的生命周期" class="headerlink" title="一、Fragment的生命周期"></a>一、Fragment的生命周期</h1><p>Fragment表示Activity中的行为或用户界面部分,其生命周期直接受宿主activity生命周期的影响。下图可以很直观反映出两者的关系：</p><p><img src="http://upload-images.jianshu.io/upload_images/1964096-c58ccce76a9aedf4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt="Fragment VS Activity"></p><p>Fragment比Activity多出的几个生命周期回调方法：</p><ul><li><p><strong>onAttach(Activity)</strong>：</p><p> called once the fragment is associated with its activity.（当Fragment和Activity相关联调用</p></li><li><p><strong>onCreateView(LayoutInflater, ViewGroup, Bundle)</strong></p><p> creates and returns the view hierarchy associated with the fragment.（创建Fragment的视图</p></li><li><p><strong>onActivityCreated(Bundle)</strong></p><p> tells the fragment that its activity has completed its own Activity.onCreate().   （当Activity.onCreate()完成时调用</p></li><li><p><strong>onDestroyView()</strong></p><p>allows the fragment to clean up resources associated with its View.</p></li><li><p><strong>onDetach()</strong></p><p>called immediately prior to the fragment no longer being associated with its activity</p></li></ul><h1 id="二、Fragment-的使用"><a href="#二、Fragment-的使用" class="headerlink" title="二、Fragment 的使用"></a>二、Fragment 的使用</h1><h2 id="静态使用"><a href="#静态使用" class="headerlink" title="静态使用"></a>静态使用</h2><p>把Fragment当做普通的控件写入Activity的布局文件中，用布局文件调用Fragment，这里不再展开</p><h2 id="动态使用"><a href="#动态使用" class="headerlink" title="动态使用"></a>动态使用</h2><p>Fragment动态使用主要是动态添加，更新，删除.</p><p>在activity的布局文件中添加一个FrameLayout，作为fragment需要放入的ViewGroup</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</div><div class="line">&lt;RelativeLayout</div><div class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    android:layout_width=<span class="string">"match_parent"</span></div><div class="line">    android:layout_height=<span class="string">"match_parent"</span></div><div class="line">    tools:context=<span class="string">"net.december1900.test.MainActivity"</span>&gt;</div><div class="line">    </div><div class="line">    &lt;FrameLayout</div><div class="line">        android:id=<span class="string">"@+id/content_layout"</span></div><div class="line">        android:layout_width=<span class="string">"match_parent"</span></div><div class="line">        android:layout_height=<span class="string">"match_parent"</span>/&gt;</div><div class="line"></div><div class="line">&lt;/RelativeLayout&gt;</div></pre></td></tr></table></figure><p>fragment和主activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.fragment_main,container,<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MainFragment mMainFragment;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        showFragment();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">()</span></span>&#123;</div><div class="line">        FragmentManager manager = getSupportFragmentManager();</div><div class="line">        FragmentTransaction fragmentTransaction = manager.beginTransaction();</div><div class="line">        mMainFragment = <span class="keyword">new</span> MainFragment();</div><div class="line">        fragmentTransaction.replace(R.id.content_layout,mMainFragment);</div><div class="line">        fragmentTransaction.commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>显示</p><p><img src="http://oq8w2ddi6.bkt.clouddn.com/fragment1.png" alt=""></p><h2 id="Fragment常用的类"><a href="#Fragment常用的类" class="headerlink" title="Fragment常用的类"></a>Fragment常用的类</h2><ol><li><p>android.app.FragmentManager</p><p>  <strong>获取方式：getSupportFragmentManager();</strong></p></li><li><p>android.app.FragmentTransaction</p><p> <strong>FragmentTransaction transaction = fm.benginTransatcion();</strong></p><ul><li><p><strong>transaction.add()</strong></p><p> 往Activity中添加一个Fragment</p></li><li><p><strong>transaction.remove()</strong></p><p> 从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁</p></li><li><p><strong>transaction.replace()</strong> </p><p> 使用另一个Fragment替换当前的，可以理解为remove() + add()</p></li><li><p><strong>transaction.hide()</strong></p><p> 隐藏当前的Fragment，仅仅是设为不可见，并不会销毁</p></li><li><p><strong>transaction.show()</strong></p><p> 显示之前隐藏的Fragment</p></li><li><p><strong>transatcion.commit()</strong></p></li></ul></li></ol><p>总结起来：</p><p><strong>如果你希望保留用户操作的面板，可以使用show(),hide()。其实是让Fragment的View setVisibility(true还是false)，不会调用生命周期</strong></p><p><strong>如果你不希望保留用户操作，可以使用replace()。其会销毁视图，即调用onDestoryView、onCreateView等一系列生命周期</strong></p><h1 id="三、管理Fragment的回退栈"><a href="#三、管理Fragment的回退栈" class="headerlink" title="三、管理Fragment的回退栈"></a>三、管理Fragment的回退栈</h1><p>我们可以通过Activity维护一个回退栈来保存每次Fragment事务发生的变化。如果将Fragment任务添加到回退栈，当用户点击后退按钮时，将看到上一次的保存的Fragment。一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则会退出当前Activity。</p><p>添加一个Fragment事务到回退栈：<br>FragmentTransaction.addToBackStack(String)</p><p>主activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MainFragment mMainFragment;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        showFragment(<span class="string">"MainFragment"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(String tag)</span> </span>&#123;</div><div class="line">        FragmentManager manager = getSupportFragmentManager();</div><div class="line">        FragmentTransaction fragmentTransaction = manager.beginTransaction();</div><div class="line">        mMainFragment = <span class="keyword">new</span> MainFragment();</div><div class="line">        fragmentTransaction.add(R.id.content_layout, mMainFragment, tag);</div><div class="line">        fragmentTransaction.addToBackStack(tag);</div><div class="line">        fragmentTransaction.commit();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>MainFragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn_main)</div><div class="line">    Button mBtnMain;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_main, container, <span class="keyword">false</span>);</div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>, view);</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_main)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewClicked</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        showFragment(<span class="string">"SecondFragment"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(String tag)</span> </span>&#123;</div><div class="line">        SecondFragment secondFragment = <span class="keyword">new</span> SecondFragment();</div><div class="line">        FragmentManager manager = getFragmentManager();</div><div class="line">        FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">        transaction.replace(R.id.content_layout, secondFragment, tag);</div><div class="line">        transaction.addToBackStack(tag);</div><div class="line">        transaction.commit();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>SecondFragment</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@BindView</span>(R.id.btn_second)</div><div class="line">    Button mBtnSecond;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        View view = inflater.inflate(R.layout.fragment_second, container, <span class="keyword">false</span>);</div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>, view);</div><div class="line">        <span class="keyword">return</span> view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_second)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewClicked</span><span class="params">()</span> </span>&#123;</div><div class="line">        showFragment(<span class="string">"ThirdFragment"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showFragment</span><span class="params">(String tag)</span> </span>&#123;</div><div class="line">        ThirdFragment thirdFragment = <span class="keyword">new</span> ThirdFragment();</div><div class="line">        FragmentManager manager = getFragmentManager();</div><div class="line">        FragmentTransaction transaction = manager.beginTransaction();</div><div class="line">        transaction.add(R.id.content_layout, thirdFragment, tag);</div><div class="line">        transaction.addToBackStack(tag);</div><div class="line">        transaction.commit();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>显示</p><p><img src="http://oq8w2ddi6.bkt.clouddn.com/fragment2.gif" alt=""></p><p>总体来说，我们调用addToBackStack(tag);将当前的事务添加到了回退栈，所以MainFragment实例不会被销毁，但是视图层次依然会被销毁，即会调用onDestoryView和onCreateView，但是使用add（）方法的SecondFragment视图层依然存在</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Fragment是在Android 3.0 (API level 11)开始引入的,它能让你的app在现有基础上性能大幅度提高，并且占用内存降低，同样的界面Activity占用内存比Fragment要多，响应速度Fragment比Activty在中低端手机上快了很多，甚至能达到好几倍,同时给大屏幕（如平板电脑）上更加动态和灵活的 UI 设计提供支持.
    
    </summary>
    
      <category term="Android" scheme="https://github.com/December1900/December1900.github.io.git/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Tinker接入指南</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2017/04/04/Tinker%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2017/04/04/Tinker接入指南/</id>
    <published>2017-04-03T16:00:00.000Z</published>
    <updated>2017-12-01T16:26:37.789Z</updated>
    
    <content type="html"><![CDATA[<p>前言：在接入Tinker前先简单了解下Tinker原理<a id="more"></a></p><p><img src="https://www.processon.com/chart_image/58e88df9e4b0a49a5ff142fb.png" alt=""></p><h1 id="TinkerPatch-接入"><a href="#TinkerPatch-接入" class="headerlink" title="TinkerPatch 接入"></a>TinkerPatch 接入</h1><p>很多接入指南和教程都是以接入Tinker为例，但实际情况一个产品不可能只有开发人员自己使用，需要能够管理和下发补丁的平台，结合实际情况选择TinkerPatch平台接入是最合适的。</p><blockquote><p>Tinker 需要使用者有一个后台可以下发和管理补丁包，并且需要处理传输安全等部署工作，TinkerPatch 平台帮你做了这些工作，提供了补丁后台托管，版本管理，保证传输安全等功能，让你无需搭建一个后台，无需关心部署操作，<strong>只需引入一个 SDK 即可立即使用 Tinker</strong></p></blockquote><h2 id="①-添加gradle依赖"><a href="#①-添加gradle依赖" class="headerlink" title="① 添加gradle依赖"></a><strong>① 添加gradle依赖</strong></h2><p>在项目的build.gradle中添加tinkerpatch-gradle-plugin的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">buildscript &#123;</div><div class="line">    repositories &#123;</div><div class="line">        jcenter()</div><div class="line">    &#125;</div><div class="line">    dependencies &#123;</div><div class="line">        <span class="comment">// TinkerPatch 插件</span></div><div class="line">        classpath <span class="string">'com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:1.1.4'</span></div><div class="line">        </div><div class="line">        <span class="comment">//不需要再引入任何Tinker依赖</span></div><div class="line">        <span class="comment">// classpath 'com.tencent.tinker:tinker-patch-gradle-plugin:1.7.7'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><strong>注意，在这里 SDK 使用了 fat 打包的模式，我们不能再引入任何 Tinker 的相关依赖，否则会造成版本冲突</strong></p></blockquote><p>然后在app的gradle文件app/build.gradle，我们可选择添加需要的库依赖以及apply tinker和tinkerpatch的gradle插件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    <span class="comment">//虽然官方文档上没有说明，但是之前没有引入的也是必须要添加的</span></div><div class="line">    compile ’com.android.support:multidex:<span class="number">1.0</span>.1‘</div><div class="line">    </div><div class="line">    <span class="comment">// 若使用annotation需要单独引用,对于tinker的其他库都无需再引用</span></div><div class="line">    provided(<span class="string">'com.tencent.tinker:tinker-android-anno:1.7.7'</span>)</div><div class="line">    compile(<span class="string">'com.tinkerpatch.sdk:tinkerpatch-android-sdk:1.1.4'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">···</div><div class="line">···</div><div class="line">apply plugin: <span class="string">'com.tencent.tinker.patch'</span></div><div class="line">apply plugin: <span class="string">'tinkerpatch-support'</span></div></pre></td></tr></table></figure><h2 id="②-配置-tinkerpatchSupport参数"><a href="#②-配置-tinkerpatchSupport参数" class="headerlink" title="② 配置 tinkerpatchSupport参数"></a><strong>② 配置 tinkerpatchSupport参数</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">def bakPath = file(<span class="string">"$&#123;buildDir&#125;/bakApk/"</span>)</div><div class="line">def baseInfo = <span class="string">"app-1.0.0-0407-22-42-41"</span></div><div class="line">def variantName = <span class="string">"release"</span></div><div class="line"></div><div class="line">tinkerpatchSupport &#123;</div><div class="line">    tinkerpatchSupport &#123;</div><div class="line">    <span class="comment">/** 可以在debug的时候关闭 tinkerPatch **/</span></div><div class="line">    tinkerEnable = <span class="keyword">true</span></div><div class="line"></div><div class="line">    <span class="comment">/** 是否使用一键接入功能  **/</span></div><div class="line">    reflectApplication = <span class="keyword">true</span></div><div class="line"></div><div class="line">    autoBackupApkPath = <span class="string">"$&#123;bakPath&#125;"</span></div><div class="line"></div><div class="line">    <span class="comment">/** 在tinkerpatch.com得到的appKey **/</span></div><div class="line">    appKey = <span class="string">"yourAppKey"</span></div><div class="line">    <span class="comment">/** 注意: 若发布新的全量包, appVersion一定要更新 **/</span></div><div class="line">    appVersion = <span class="string">"1.0.0"</span></div><div class="line"></div><div class="line">    def pathPrefix = <span class="string">"$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/"</span></div><div class="line">    def name = <span class="string">"$&#123;project.name&#125;-$&#123;variantName&#125;"</span></div><div class="line"></div><div class="line">    baseApkFile = <span class="string">"$&#123;pathPrefix&#125;/$&#123;name&#125;.apk"</span></div><div class="line">    baseProguardMappingFile = <span class="string">"$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt"</span></div><div class="line">    baseResourceRFile = <span class="string">"$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述是需要自行配置的代码模块，其他引入参考:<a href="https://github.com/TinkerPatch/tinkerpatch-sample/blob/master/app/tinkerpatch.gradle">tinkerpatch.gradle </a><br>针对特殊需求，具体的参数含义可参考 Tinker 文档:<a href="https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97">Tinker接入指南.</a></p><h2 id="③-初始化-TinkerPatch-SDK"><a href="#③-初始化-TinkerPatch-SDK" class="headerlink" title="③ 初始化 TinkerPatch SDK"></a><strong>③ 初始化 TinkerPatch SDK</strong></h2><h3 id="1-reflectApplication-true-的情况"><a href="#1-reflectApplication-true-的情况" class="headerlink" title="1.reflectApplication = true 的情况"></a><strong>1.reflectApplication = true 的情况</strong></h3><p>若我们使用 reflectApplication 模式，我们无需为接入 Tinker 而改造我们的 Application 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        <span class="comment">// 我们可以从这里获得Tinker加载过程的信息</span></div><div class="line">        tinkerApplicationLike = TinkerPatchApplicationLike.getTinkerPatchApplicationLike();</div><div class="line"></div><div class="line">        <span class="comment">// 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化SDK</span></div><div class="line">        TinkerPatch.init(tinkerApplicationLike)</div><div class="line">            .reflectPatchLibrary()</div><div class="line">            .setPatchRollbackOnScreenOff(<span class="keyword">true</span>)</div><div class="line">            .setPatchRestartOnSrceenOff(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 每隔3个小时去访问后台时候有更新,通过handler实现轮训的效果</span></div><div class="line">        <span class="keyword">new</span> FetchPatchHandler().fetchPatchWithInterval(<span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure><h3 id="2-reflectApplication-false-的情况"><a href="#2-reflectApplication-false-的情况" class="headerlink" title="2.reflectApplication = false 的情况"></a>2.reflectApplication = false 的情况</h3><p>若我们已经完成了应用的 Application 改造，即将 Application 的逻辑移动到 ApplicationLike类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        <span class="comment">// 初始化TinkerPatch SDK, 更多配置可参照API章节中的,初始化 SDK</span></div><div class="line">        TinkerPatch.init(<span class="keyword">this</span>)</div><div class="line">            .reflectPatchLibrary()</div><div class="line">            .setPatchRollbackOnScreenOff(<span class="keyword">true</span>)</div><div class="line">            .setPatchRestartOnSrceenOff(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 每隔3个小时去访问后台时候有更新,通过handler实现轮训的效果</span></div><div class="line">        <span class="keyword">new</span> FetchPatchHandler().fetchPatchWithInterval(<span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="④-使用步骤（Release为例）"><a href="#④-使用步骤（Release为例）" class="headerlink" title="④ 使用步骤（Release为例）"></a><strong>④ 使用步骤（Release为例）</strong></h2><h3 id="使用gradle-进行apk签名打包"><a href="#使用gradle-进行apk签名打包" class="headerlink" title="使用gradle 进行apk签名打包"></a>使用gradle 进行apk签名打包</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">android &#123;  </div><div class="line"></div><div class="line">&lt;!--    signingConfigs &#123;  </div><div class="line">        releaseConfig &#123;  </div><div class="line">            keyAlias <span class="string">'stone'</span>  </div><div class="line">            keyPassword <span class="string">'mypwd'</span>  </div><div class="line">            <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">'/Users/stone/Documents/project_AS/myapplication/stone.keystore'</span>)</span>  </span></div><div class="line"><span class="function">            storePassword 'mypwd'  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">    &#125; --&gt;</span></div><div class="line"><span class="function">      </span></div><div class="line"><span class="function"><span class="comment">//但是签名密码写在gradle中不安全</span></span></div><div class="line"><span class="function"><span class="comment">//这样在命令执行时，就会被要求输入密码</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">android </span>&#123;  </div><div class="line">    signingConfigs &#123;  </div><div class="line">        releaseConfig &#123;  </div><div class="line">        <span class="function">storeFile <span class="title">file</span><span class="params">(<span class="string">"stone.keystore"</span>)</span>  </span></div><div class="line"><span class="function">        storePassword System.<span class="title">console</span><span class="params">()</span> !</span>= <span class="keyword">null</span> ? System.console().readLine(<span class="string">"\nKeystore password: "</span>) : <span class="string">""</span> </div><div class="line">        keyAlias <span class="string">"stone"</span>  </div><div class="line">        keyPassword System.console() != <span class="keyword">null</span> ? System.console().readLine(<span class="string">"\nKey password: "</span>) : <span class="string">""</span> </div><div class="line">  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">     </div><div class="line">     buildTypes &#123;  </div><div class="line">        release &#123;  </div><div class="line">        ...  </div><div class="line">        signingConfig signingConfigs.release  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><ul><li><strong>0. 运行<code>./gradlew assembleRelease</code> 构建基准包</strong></li></ul><p>For some reason, running gradle in daemon mode causes a null console object.</p><blockquote><p>Cannot invoke method readLine() on null object</p></blockquote><p>解决方法</p><blockquote><p>./gradlew assembleRelease –no-daemon</p></blockquote><ul><li><p><strong>1. 运行./gradlew assembleRelease –no-daemon构建基准包</strong></p></li><li><p><strong>2. 将步骤一中保存下来的文件手动填到baseInfo/中</strong></p></li></ul><p>因为之前路径已经配置好，所以只需要把release.apk填写入baseInfo</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/tinker-1.png" alt=""></p><ul><li><strong>3. 修改源代码，运行./gradlew tinkerPatchRelease –no-daemon构建补丁包，补丁包将位于 build/outputs/tinkerPatch 中</strong></li></ul><p><img src="http://oe90x7ww9.bkt.clouddn.com/tinker-2.png" alt=""></p><ul><li><strong>4. 将patch_signed _7zip.apk加入管理平台</strong></li></ul><hr><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><h2 id="1-关于Application的改造"><a href="#1-关于Application的改造" class="headerlink" title="1.关于Application的改造"></a>1.关于Application的改造</h2><p>Tinker自定义扩展：<a href="https://github.com/Tencent/tinker/wiki/Tinker-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95#%E8%87%AA%E5%AE%9A%E4%B9%89application%E7%B1%BB">自定义Application类</a></p><h2 id="2-如何做多次修复？"><a href="#2-如何做多次修复？" class="headerlink" title="2.如何做多次修复？"></a>2.如何做多次修复？</h2><p>Tinker支持对同一基准版本做多次补丁修复，每次生成补丁包后，tinker会生成加上补丁包的新包，这时需要将基准包替换为最新的，即补丁版本二的oldApk不能是补丁版本一。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mp.weixin.qq.com/s/GuzbU1M1LY1VKmN7PyVbHQ" target="_blank" rel="external">主流热修复方案简介</a></li><li><a href="https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97">Tinker接入指南</a></li><li><a href="http://tinkerpatch.com/Docs/SDK" target="_blank" rel="external">TinkerPatch SDK接入</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：在接入Tinker前先简单了解下Tinker原理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2016。2017，</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2017/01/29/2017/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2017/01/29/2017/</id>
    <published>2017-01-29T14:57:34.000Z</published>
    <updated>2017-12-01T12:37:02.250Z</updated>
    
    <content type="html"><![CDATA[<p>2016年，和超哥一同完成了<a href="https://ccnubox.muxixyz.com" target="_blank" rel="external"><strong>「华师匣子」</strong></a>的开发，也离不开项目组每个人的付出。</p><p>2016年，和团队所有成员一起圆满完成了匣子一版的宣传工作，真的辛苦了。</p><p>2016年，<a href="http://muxistudio.com" target="_blank" rel="external">团队</a>走的很曲折，即便如此也未曾偏离过正确的航道。<a id="more"></a></p><p>2016年，在光谷第一次参加hackathon，作为嘉宾在上海参加了Google Developer Day，收获很多。</p><p>2016年，和Kasheemlew以及一群特立独行的猪结下了深厚的友谊。</p><p>2016年，4月14日，科比退役。</p><p>2016年，遇到了陪我度过很多不开心时光的Running Man。</p><p>2016年，喜欢上原来Hip Hop也可以这样的Gary和Leessang，好的歌曲总是能产生共鸣。</p><p>2016年，所设的目标最终大部分都摘到了，也对自己的学习和人生规划做了很多思考，但很多时候活的却不像自己。</p><p>2016年，遇见了让自己心动的女生，却因为各种各样乱七八糟的原因最后也没表达自己的心声，这应该是最遗憾的事情。</p><h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><p>每个人心中都藏着一个无法妥协的自己</p><p>为人生之路带来痛苦</p><p>遗憾的是我们并没有逃离那种痛苦的手段</p><p>但是，不能一味受自身软弱所摆布</p><p>从而沉溺于痛苦</p><p>我们还能为正视弱小的自己</p><p>为抗争，为改变去承受痛苦</p><p>人，远比想象的要自由</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/%E5%90%88%E5%9B%BE1.jpg" alt="合图1"></p><p><img src="http://oe90x7ww9.bkt.clouddn.com/%E5%90%88%E5%9B%BE2.jpg" alt="合图2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，和超哥一同完成了&lt;a href=&quot;https://ccnubox.muxixyz.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;「华师匣子」&lt;/strong&gt;&lt;/a&gt;的开发，也离不开项目组每个人的付出。&lt;/p&gt;
&lt;p&gt;2016年，和团队所有成员一起圆满完成了匣子一版的宣传工作，真的辛苦了。&lt;/p&gt;
&lt;p&gt;2016年，&lt;a href=&quot;http://muxistudio.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;团队&lt;/a&gt;走的很曲折，即便如此也未曾偏离过正确的航道。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Google Developer Day 上海 2016 Thoughts</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/12/16/GDD2016/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/12/16/GDD2016/</id>
    <published>2016-12-15T16:00:00.000Z</published>
    <updated>2017-12-01T15:58:11.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a><strong>Review</strong></h1><p>前天参加了在上海国家会议中心举行的Goolge Developer Day，与其说是开发者大会，感觉用推广大会来描述会更准确。但不得不说Google确实是全球科技的领先者，这次活动很全面的展示了如何使用谷歌的开发工具和其强大的生态，覆盖了移动应用开发（Andorid/Web/Firebase）,VR（DayDream/Tango）,AI（TensorFlow），Adwords。<a id="more"></a></p><p><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:gdd:start.jpg" alt="image1"></p><p>9：00–18：30，Goolge按照领域划分了不同的主题演讲，嘉宾按照自己的喜好选择即可，诚意还是十足基本都是高管或者大牛。简单整理下一些自己的想法，略显遗憾的是没有玩到DayDream，哈哈。</p><hr><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a><strong>Android</strong></h1><p><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:gdd:android.jpg" alt="image2"></p><p>随着Android 7.0的发布，Android也正式进入牛轧糖时代。那这次开发者大会也是更多的展示Android新版本（7.1.1），开发工具，支持库的新功能，整体偏文档化，对我们开发者而言已经是耳熟能详的东西，略显遗憾，但也有平常不常见的细节分享，以及一些工具向后兼容的问题总体来说实质性的干货偏少。</p><p>接着是宣布了一款专门针对中国市场的Android Wear 2.0开发者预览版，尽管如此也掩饰不了尴尬的字眼，没有明确成型的适配方案（现场是这么回答的，不知道是出于商业目的还是确实是没有好的规划，加上本身Android碎片化和本土定制化程度高，Android Wear如何更好地发展也扑朔迷离。</p><p>最后是Android开发中的省电和内存优化，其实Android本身是需要硬件支撑的，但同时好的硬件功耗和占用率也会相应高很多，所以其实Android一直都在尝试解决省电和内存优化问题，无奈Android碎片化太严重，尤其在国内加上各式各样阉割定制系统，十八般武艺常常不能得到发挥。这次带来更新的Doze和App Standby，其中Doze直接干掉了网络访问功能和异步Adapters以及JobScheduler，功能上还是值得期待的，但实际效果和支持级别略高（API 23 都是需要去考虑的问题。但无论如何Android一直都在为成为更好，更优秀，更有创造力的系统而努力。</p><h1 id="Pixel"><a href="#Pixel" class="headerlink" title="Pixel"></a><strong>Pixel</strong></h1><p><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:gdd:pixel.jpg" alt="image3"><br><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:gdd:pixel2.jpg" alt="image4"></p><p>能让我心甘情愿舍弃DayDream机会的pixel确实也没让我怎么失望，Android Nougat 7.1 搭配Google重量级AI产品—Goolge Assistance通过你的语音或者屏幕上的信息提供了更有用的信息和个性化服务，比如解决问题，辅助日常，更高效地搜索个人图片等，而无论是转场动画还是过渡动画，包括整个UI的布局以及小细节，Nougat几乎让你感觉不到卡顿，整个动画过程一气呵成却不失美感。而Goolge Assistance的表现着实让人有了更大的期待，不得不说在人工智能方面（科技 方面Google都是领先于微软和苹果的。</p><p>同时相机表现异常优秀，样张干净，色彩还原好，白平衡精准，底噪少，让人眼感觉非常舒适。</p><p>但还是忍不住吐糟几句：HTC传统宽下巴还在，电池容量小的可怜，基本无力吐槽的屏占比，极差的手感和产品细节，正面背面随意开孔毫无美感可言，后背设计是什么鬼。说实话正面没home键和我手上的iPhone 7没什么区别，却和iPhone 7相同的价格……</p><h1 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a><strong>Material Design</strong></h1><p><img src="http://oq8w2ddi6.bkt.clouddn.com/blog:gdd:md.jpg" alt="image5"></p><p>Material Design主题分享也基本是文档上的再说明，补充的what we learned还是很好做出了一些使用上的总结，尽管也是开发者和设计师耳熟能详的例子。</p><p>演讲嘉宾做完主题分享后就是提问环节，当时还在做笔记，也不知道当时哪里来的这么大勇气，可能确实一直以来困扰自己的问题，马上就举手站起来提问了。当时是真的没想很多，因为演讲嘉宾是外国友人就用英文提了两个问题（后来仔细想想应该在底下组织好语言的。</p><p>期间有不少人转过来看，搞得本来不紧张的我到最后直哆嗦。整个过程结束后，外国友人给了我大拇指，现场也送上了挺热烈的掌声。即使是现在也挺满足开心的，没有比在理想道路上奔跑时得到认可更幸福的事了，所以我会继续努力下去，不辜负自己活着。</p><p>但是演讲嘉宾的回答也太官方了…..也怪当时自己忘记戴同传了理解起来有点吃力。</p><p>问：我们都知道并不是所有App使用Material Design都好，有哪些应用不需要使用Material Design或者Material Design不适合，比如工具类App？<br>答：游戏不适合…对那你说的工具类我觉得不使用要比使用的好。</p><p>问：由于Material Design并没有给出一个现有和准确的配色方案，我和我的设计师讨论究竟如何选择primary color和accent color才是最好的？<br>答：这主要看你们的app想要给用户展现什么样的思想..(省略..呈现的大部分区域使用primary color，需要高亮显示的使用accent color。</p><hr><h1 id="Tail"><a href="#Tail" class="headerlink" title="Tail"></a><strong>Tail</strong></h1><p>Google 这次显示是有备而来，Web+Android+Firebase+VR+AI展现了自己强大整套生态,还是那句话Google是全球顶尖的科技公司，总是能给人们带来惊喜，让人们有勇气去憧憬未来，所以期待完整体的Google回归中国。</p><p>离2016结束也只有一个多月了，希望自己在年终总结的不要留有遗憾。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Review&quot;&gt;&lt;a href=&quot;#Review&quot; class=&quot;headerlink&quot; title=&quot;Review&quot;&gt;&lt;/a&gt;&lt;strong&gt;Review&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;前天参加了在上海国家会议中心举行的Goolge Developer Day，与其说是开发者大会，感觉用推广大会来描述会更准确。但不得不说Google确实是全球科技的领先者，这次活动很全面的展示了如何使用谷歌的开发工具和其强大的生态，覆盖了移动应用开发（Andorid/Web/Firebase）,VR（DayDream/Tango）,AI（TensorFlow），Adwords。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈快充技术</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/10/10/Android-QCharge/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/10/10/Android-QCharge/</id>
    <published>2016-10-09T16:00:00.000Z</published>
    <updated>2017-12-01T12:37:41.974Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:<br>近两年准确来说是去年上半年，对于Android阵营快充基本已经成为各大中高端机型的标配，iPhone额…Apple反正是一直掖着藏着当然是用iPad充电器也可以大幅提高速度（相对iPhone而言）<a id="more"></a></p><hr><h1 id="快充技术原理"><a href="#快充技术原理" class="headerlink" title="快充技术原理"></a>快充技术原理</h1><p>如果初中上语文课有认真听讲的话一定记得下面的这个公式:<br>    P「电功率」＝ U「电压」X I「电流」<br>这样自然提升功率的无异两种方法，要么提升电压，要么加大电流.我们通常把大于5V的电压称为高电压，大于1.5A的电流称为高电流.</p><p>目前采用高电压方案的厂家有高通，苹果，联发科，德州仪器.<br>而采用高电流方案的厂家主要是OPPO.</p><h1 id="三大主流快充方案"><a href="#三大主流快充方案" class="headerlink" title="三大主流快充方案"></a>三大主流快充方案</h1><h2 id="高通-「QC」-Quick-Charge-技术"><a href="#高通-「QC」-Quick-Charge-技术" class="headerlink" title="高通 「QC」(Quick Charge)技术"></a><strong>高通 「QC」(Quick Charge)技术</strong></h2><p>QC的原理是通过USB端口的D+与D-的不同电压给合，来向充电器申请相应的输出电压供手机充电。快充的充电器与手机通过USB接口中间两线（D+D-）上加载电压来进行通讯，调节QC的输出电压，达到所需要的高电压。但是如果当充电器的调压档跨度比较大，手机端充电路效率偏低.</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/QC3.0.gif" alt="QC3.0"></p><p>最新发布的<strong>QC3.0</strong>更合理高效:</p><blockquote><p>Quick Charge 3.0 employs Intelligent Negotiation for Optimum Voltage (INOV), an algorithm which allows your portable device to determine what power level to request at any point in time, enabling optimum power transfer while maximizing efficiency. It also supports wider voltage options, allowing a mobile device to dynamically adjust to the ideal voltage level supported by that specific device. Specifically, Quick Charge 3.0 offers a more granular range of voltages: 200mV increments, from 3.6V to 20V. That way your phone can target one of dozens of power levels.</p></blockquote><p>简而言之就是Quick Charge 3.0再采用最佳电压智能协商（INOV）算法后，支持更细化的电压选择：以200mV增量为一档，提供从3.6V到20V电压的灵活选择。这样，你的手机可以从数十种功率水平中选择最适合的一档。</p><h2 id="联发科-「Pump-Express-Plus」技术"><a href="#联发科-「Pump-Express-Plus」技术" class="headerlink" title="联发科 「Pump Express Plus」技术"></a><strong>联发科 「Pump Express Plus」技术</strong></h2><p>Pump Express是通过USB端口的VBUS来向充电器通讯并申请相应的输出电压的。QC是通过配置D+和D-电压的方式来通讯，Pump Express则是通过VBUS上的电流脉冲来通讯.但是和前代QC一样当充电器的调压档跨度比较大，带来手机端充电路效率偏低.</p><p>Pump Express Plus技术与高通QC3.0类似，增加了调压档数，可以向充电器申请合适的电压，以达到电效率的最大化，每档200mV，受控电压为12V/9V/7V，功率在15W以上。而采用联发科-TI快充方案的魅族mcharge3.0更是达到恐怖的24W，足见联发科在快充方面不容小觑的实力。</p><h2 id="德州仪器-TI-「MaxCharge」技术"><a href="#德州仪器-TI-「MaxCharge」技术" class="headerlink" title="德州仪器(TI) 「MaxCharge」技术"></a><strong>德州仪器(TI) 「MaxCharge」技术</strong></h2><p>TI MaxCharge快充技术集成了5A单节锂离子电池充电器电路，在电流高达5A的时候支持高达14V的输入电压。向下兼容高通QC的9V、12V两档电压，对联发科Pump Express Plus的7V、9V、12V支持也不在话下，联合TI自身的高性能充电管理做了一次整合。</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/TI-MaxCharge.jpg" alt="TI-MaxCharge"></p><hr><p><strong>上述的高电压方案都需要通过手机电源转换模块将交流电的「高电压，小电流」转换为直流电「低电压，大电流」，而此时会产生高频脉冲会影响元器件的工作和寿命，同时机身会发热严重。</strong><br><strong>那这么说就是说采用高电流方案会更合理喽，不妨接着往下看。</strong></p><hr><h2 id="OPPO-「VOOC」技术"><a href="#OPPO-「VOOC」技术" class="headerlink" title="OPPO 「VOOC」技术"></a><strong>OPPO 「VOOC」技术</strong></h2><p>VOOC技术（一加的「DASH技术」同理）的原理与上述不一样是采用的高电流方案，同事充电器和电池电路中都整合了智能控制芯片MCU来取代降压电路，智能控制充电的整个流程。</p><p>采用高电流方案的OPPO确实不用担心电压转换问题，但同时难度也来了，在狭小的手机空间里，整条线路（数据线，USB，电池等等）都要改造禁得起起大电流的元器件，这样一来就需要专用充电器，7pin口的USB线，电池etc.</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/OPPO-VOOC.png" alt="OPPO-VOOC"></p><p>也正因为这样充电控制电路移植到了适配器端，也就是将最大的发热源移植到了适配器。这样控制电路在适配器，而被充电的电池在手机端，充电时手机发热得以很好的解决，同时也保证了高效率。</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/VOOC.png" alt="VOOC"></p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><h2 id="「结尾」"><a href="#「结尾」" class="headerlink" title="「结尾」"></a>「结尾」</h2><p>不知道大家有没有仔细观察，快充是不能一直持续的，当电池容量达到90%后速度会明显放缓，其实这时已经是恒压充电了。电池好比一个气球，当前期气球比较小时，我们可以随意加速打气，但当气球大到一定程度时，承受能力也达到了临界值，那这时候就需要减小进气量，控制得当，防止爆炸，也就是我们所说的防溢出。<br>所以我们看到不管是哪种快充协议，都是前期爆发式充电，将效率最大化，而到了90%的电量后，则进入涓流充电，充电器与设备里的芯片协同工作，以控制进入电池的电流。</p><hr><h2 id="「吐槽」"><a href="#「吐槽」" class="headerlink" title="「吐槽」"></a>「吐槽」</h2><p>上面提到过电流大幅度增加势必造成Micro USB接口和数据线无法承受，所以OPPO是使用了7pin接口，相比于普通的USB接口5个接触点7pin有8个接触点，算是特别定制的，但是现在的USB Type C接口的触点数量数倍于Micro USB接口，这就使得它能承受的电流强度大大增加;同时TC加入了互相识别的步骤，可以把自己定义成充电器或者受电设备。换句话说Type C天然支持快充，同样的电流下Type C损失也会更小，而且可以支持双向充电。所以说使用了Type C而不支持快充的都是耍流氓，比如不将就的上旗舰（披着Type C的USB2.0）</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/%E4%B8%80%E5%8A%A02.jpeg" alt="一加2"></p><hr><h2 id="「尾巴」"><a href="#「尾巴」" class="headerlink" title="「尾巴」"></a>「尾巴」</h2><p>其实孰优孰劣本没有一个明显的划分，但即使高电压方案存在些许问题，由于高通，联发科，苹果这些上游芯片级厂商的号召力和影响力，加上高电压方案只需要一个充电器的高兼容性和方便性，高电压方案会是未来一段时间的主流。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;br&gt;近两年准确来说是去年上半年，对于Android阵营快充基本已经成为各大中高端机型的标配，iPhone额…Apple反正是一直掖着藏着当然是用iPad充电器也可以大幅提高速度（相对iPhone而言）
    
    </summary>
    
      <category term="Android" scheme="https://github.com/December1900/December1900.github.io.git/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac环境下快速反编译APK</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/09/29/Android-decompile/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/09/29/Android-decompile/</id>
    <published>2016-09-28T16:00:00.000Z</published>
    <updated>2017-12-01T15:57:46.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h1><p><a href="https://github.com/dirkvranckaert/AndroidDecompiler">AndroidDecompiler</a>（apktool、dex2jar）、<a href="https://github.com/java-decompiler/jd-gui">jd-gui</a><a id="more"></a></p><p><img src="http://oe90x7ww9.bkt.clouddn.com/%E5%8F%8D%E7%BC%96%E8%AF%91%E6%88%AA%E5%9B%BE.png" alt="AndroidDecompiler"></p><hr><h1 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h1><h2 id="反编译AndroidManifest-xml和资源文件"><a href="#反编译AndroidManifest-xml和资源文件" class="headerlink" title="反编译AndroidManifest.xml和资源文件"></a>反编译AndroidManifest.xml和资源文件</h2><p>为了防止文件内容和位置混乱，最好新建一个目录来进行反编译操作(/users/username/downloads/test)具体依照个人习惯，然后将需要反编译的apk(以app-release.apk为例子)和AndroidDecompiler目录下的dex2jar均copy到相应的目录下.</p><p>再使用apktool反编译apk，可以获得AndroidManifest.xml和资源文件.</p><blockquote><p>$ apktool d app-release.apk</p></blockquote><p>执行完输出后，目录会新增一个app-release文件夹，里面有我们想要的res/和xml，到此资源文件已经反编译完成.</p><h2 id="反编译java代码"><a href="#反编译java代码" class="headerlink" title="反编译java代码"></a>反编译java代码</h2><p>1.先解压.apk文件</p><blockquote><p>//解压app-release.apk到指定新建的app-release_source目录下<br>$ unzip app-release.apk -d app-release_source</p></blockquote><p>2.反编译.dex文件</p><blockquote><p>//在app-release_source目录下找到classes.dex并反编译为.class文件<br>$ sh dex2jar/d2j-dex2jar.sh app-release_source/classes.dex</p></blockquote><p>3.使用jd-gui打开第二步编译出的classes-dex2jar.jar文件</p><p><img src="http://oe90x7ww9.bkt.clouddn.com/%E5%8F%8D%E7%BC%96%E8%AF%91jd-gui.png" alt="jd-gui"></p><p>OK此时各种变量已经被混淆，说明反编译成功</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;工具准备&quot;&gt;&lt;a href=&quot;#工具准备&quot; class=&quot;headerlink&quot; title=&quot;工具准备&quot;&gt;&lt;/a&gt;工具准备&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dirkvranckaert/AndroidDecompiler&quot;&gt;AndroidDecompiler&lt;/a&gt;（apktool、dex2jar）、&lt;a href=&quot;https://github.com/java-decompiler/jd-gui&quot;&gt;jd-gui&lt;/a&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android 跳坑微信推送</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/09/07/Android-shareWechat/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/09/07/Android-shareWechat/</id>
    <published>2016-09-06T16:00:00.000Z</published>
    <updated>2017-12-01T12:37:59.218Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:只调用微信分享一个接口就仿佛陷入了无底洞，在错误的泥潭里越陷越深，最开(dan)心(teng)的是网上文章各有各的套路，再就是错误问题有些解释的不太明了，当然这锅大部分得要微信自己来背，排版无力吐槽而且漏洞多还不太稳定。<a id="more"></a></p><hr><h1 id="配置和接入"><a href="#配置和接入" class="headerlink" title="配置和接入"></a>配置和接入</h1><ul><li><p>前面配置按照官方文档一步步来就可以了，记住加上所需要的权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--微信权限--&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.ACCESS_WIFI_STATE"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_PHONE_STATE"</span>/&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</div></pre></td></tr></table></figure></li><li><p>注册发送请求到微信，并接入分享功能，以【<strong>链接分享</strong>】为例(其他分享格式参照官方文档)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//APP_ID为微信注册成功显示的APP_ID</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_ID = <span class="string">"wx888888888"</span>;</div><div class="line"><span class="keyword">private</span> IWXAPI api;</div><div class="line">  </div><div class="line"><span class="comment">//transaction需要的类型</span></div><div class="line"><span class="keyword">private</span> String type = <span class="string">"webpage"</span>;</div><div class="line">  </div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_web);</div><div class="line">    shareTOWeixin();</div><div class="line">    &#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shareTOWeixin</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">//不太理解这里false和true有什么作用</span></div><div class="line">    api = WXAPIFactory.createWXAPI(getApplicationContext(), APP_ID, <span class="keyword">false</span>);</div><div class="line">    api.registerApp(APP_ID);</div><div class="line">    </div><div class="line">    WXWebpageObject webpage = <span class="keyword">new</span> WXWebpageObject();</div><div class="line">    webpage.webpageUrl = url;</div><div class="line">    WXMediaMessage msg = <span class="keyword">new</span> WXMediaMessage(webpage);</div><div class="line">    msg.title = title;</div><div class="line">    msg.description = intro;</div><div class="line">    Bitmap thumbBmp = Bitmap.createScaledBitmap(bmp, <span class="number">150</span>, <span class="number">150</span>, <span class="keyword">true</span>);</div><div class="line">    bmp.recycle();</div><div class="line">    msg.setThumbImage(bmp);</div><div class="line">    SendMessageToWX.Req req = <span class="keyword">new</span> SendMessageToWX.Req();</div><div class="line">    req.transaction = type + System.currentTimeMillis();</div><div class="line">    req.message = msg;</div><div class="line">    req.scene = SendMessageToWX.Req.WXSceneTimeline;</div><div class="line">    api.sendReq(req);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h1 id="跳坑-带泪的亲历"><a href="#跳坑-带泪的亲历" class="headerlink" title="跳坑(带泪的亲历)"></a>跳坑(带泪的亲历)</h1><ul><li>一定要在你的包名根目录下创建wxapi包，然后在该包下创建activity命名为【<strong>WXEntryActivity</strong>】(写死不可更改)并实现IWXAPIEventHandler接口，不然怎么挂的都不知道</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WXEntryActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">IWXAPIEventHandler</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APP_ID = <span class="string">"wxf054659decf8f748"</span>;</div><div class="line"><span class="keyword">private</span> IWXAPI api;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">    api = WXAPIFactory.createWXAPI(<span class="keyword">this</span>, APP_ID,<span class="keyword">false</span>);</div><div class="line">    api.registerApp(APP_ID);</div><div class="line">    api.handleIntent(getIntent(),<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReq</span><span class="params">(BaseReq baseReq)</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResp</span><span class="params">(BaseResp baseResp)</span> </span>&#123;</div><div class="line">    String result = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (baseResp.errCode)&#123;</div><div class="line">        <span class="keyword">case</span> BaseResp.ErrCode.ERR_OK:</div><div class="line">            result = <span class="string">"发送成功"</span>;</div><div class="line">            Toast.makeText(<span class="keyword">this</span>,result,Toast.LENGTH_SHORT).show();</div><div class="line">            finish();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BaseResp.ErrCode.ERR_USER_CANCEL:</div><div class="line">            result = <span class="string">"发送失败"</span>;</div><div class="line">            Toast.makeText(<span class="keyword">this</span>,result,Toast.LENGTH_SHORT).show();</div><div class="line">            finish();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> BaseResp.ErrCode.ERR_AUTH_DENIED:</div><div class="line">            result = <span class="string">"发送被拒绝"</span>;</div><div class="line">            Toast.makeText(<span class="keyword">this</span>, result, Toast.LENGTH_LONG).show();</div><div class="line">            finish();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            result = <span class="string">"发送返回"</span>;</div><div class="line">            Toast.makeText(<span class="keyword">this</span>, result, Toast.LENGTH_LONG).show();</div><div class="line">            finish();</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onNewIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onNewIntent(intent);</div><div class="line">    setIntent(intent);</div><div class="line">    api.handleIntent(intent, <span class="keyword">this</span>);</div><div class="line">    finish();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="分享未成功"><a href="#分享未成功" class="headerlink" title="分享未成功"></a>分享未成功</h2><ul><li><strong>调试(分享)功能时要打【app-release.apk】，并且要对照本地签名和微信服务器端签名是否一致</strong></li></ul><blockquote><p>使用GenSignature获取release包的签名，并和服务器端的应用签名核对是否一致，若不一致，修改服务器端应用签名和本地签名一致，大概需要半天时间同步。</p></blockquote><ul><li>若返回结果的为”发送返回”，极大可能是因为修改了appkey(签名)和储存在sharepreference中的access token不匹配，所以被分享平台拒绝。解决办法就是清空微信缓存或者重装微信应用，再或者换一部手机调试都是可行的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:只调用微信分享一个接口就仿佛陷入了无底洞，在错误的泥潭里越陷越深，最开(dan)心(teng)的是网上文章各有各的套路，再就是错误问题有些解释的不太明了，当然这锅大部分得要微信自己来背，排版无力吐槽而且漏洞多还不太稳定。
    
    </summary>
    
      <category term="Android" scheme="https://github.com/December1900/December1900.github.io.git/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 跳坑信鸽推送</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/09/03/Android-xgpush/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/09/03/Android-xgpush/</id>
    <published>2016-09-02T16:00:00.000Z</published>
    <updated>2017-12-01T12:38:08.018Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面:</p><p>不得不说信鸽推送真是坑超多，尤其官方文档跟没讲一样,心累整理详细流程(SDK 2.46)<a id="more"></a></p><hr><h1 id="配置和注册"><a href="#配置和注册" class="headerlink" title="配置和注册"></a>配置和注册</h1><p>  基本流程按照官方文档来，代码直接copy就可以了，不过需要注意几点.</p><ul><li><p><strong>使用AS要根据提示设置android:name=android.intent.action</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">"com.tencent.android.tpush.XGPushActivity"</span></div><div class="line">    android:exported=<span class="string">"true"</span>&gt;</div><div class="line">    &lt;intent-filter&gt;</div><div class="line">        &lt;!-- 若使用AndroidStudio，请设置android:name=<span class="string">"android.intent.action"</span>--&gt;</div><div class="line">        &lt;action android:name=<span class="string">"android.intent.action"</span>/&gt;</div><div class="line">    &lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure><ul><li><strong>正确配置XGRemoteService，且intent-filter中是否正确设置</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;action android:name=<span class="string">"应用包名.PUSH_ACTION"</span> /&gt; 应用包名为当前APP包名</div></pre></td></tr></table></figure><ul><li><strong>完成配置后，在工程的主activity(一般都是mainactivity)onCreate重载方法里添加如下代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Context context = getApplicationContext();</div><div class="line">          XGPushConfig.enableDebug(<span class="keyword">this</span>,<span class="keyword">true</span>);</div><div class="line">          XGPushConfig.getToken(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">//为了方便获取注册是否成功的状态，使用带callback的版本</span></div><div class="line">  XGPushManager.registerPush(context,<span class="string">"users"</span>,newXGIOperateCallback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span> <span class="params">(Object data,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">            Log.d(<span class="string">"TPush"</span>, <span class="string">"注册成功，设备token为："</span> + data);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span> <span class="params">(Object data,<span class="keyword">int</span> errCode, String msg)</span></span>&#123;</div><div class="line">            Log.d(<span class="string">"TPush"</span>, <span class="string">"注册失败，错误码："</span> + errCode + <span class="string">",错误信息："</span> + msg);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></li></ul><ul><li><p><strong>正确输入自己的ACCESS ID和ACCESS KEY</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> &lt;!-- 【必须】 请将YOUR_ACCESS_ID修改为APP的AccessId，“<span class="number">21</span>”开头的<span class="number">10</span>位数字，中间没空格 --&gt;</div><div class="line">&lt;meta-data</div><div class="line">    android:name=<span class="string">"XG_V2_ACCESS_ID"</span></div><div class="line">    android:value=<span class="string">"21********"</span>/&gt;</div><div class="line">&lt;!-- 【必须】 请将YOUR_ACCESS_KEY修改为APP的AccessKey，“A”开头的<span class="number">12</span>位字符串，中间没空格 --&gt;</div><div class="line">&lt;meta-data</div><div class="line">    android:name=<span class="string">"XG_V2_ACCESS_KEY"</span></div><div class="line">    android:value=<span class="string">"A***********"</span>/&gt;</div></pre></td></tr></table></figure></li></ul><hr><h1 id="跳坑-带泪的亲历"><a href="#跳坑-带泪的亲历" class="headerlink" title="跳坑(带泪的亲历)"></a>跳坑(带泪的亲历)</h1><p>如果觉得这么简单就完了，那真是too young too simple了，坑得一步步跳</p><ul><li><strong>按照指示将下载下来的libs中的so和jar集成到AS上的libs中去，其中V4包直接删掉因为没有谁不带support库的，然后要在build.gradle添加如下代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line"> main&#123;</div><div class="line"> jniLibs.srcDirs=[<span class="string">'libs'</span>]&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><ul><li><p><strong>编译时候出现无法找到so文件</strong></p><ul><li><p>第一是需要添加多个平台的so文件，只按照官方文档添加一个armeabi是肯定行不通的，因为每个品牌的手机需要的so文件是不一样的，如果做测试肯定需要每个平台的so文件来适配主流手机</p><p> 拿我自己来说魅族手机需要添加armeabi，armeabi-v7，arm64-v8a<br> 但小米就只需要添加armeabi,armeabi-v7 </p></li><li>第二如果工程之前就添加了某些平台的so文件(比如andfix)，则需要把所有的so文件分平台「<strong>合并</strong>」否则也会找不到so文件</li></ul></li></ul><ul><li><p><strong>logcat显示XGRemotService无法认证显示</strong></p><blockquote><p><strong>这说明自己工程的id和推上信鸽的应用包名不一致，也就是信鸽显示的应用包名错误，需要重新提交应用保持一致</strong></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面:&lt;/p&gt;
&lt;p&gt;不得不说信鸽推送真是坑超多，尤其官方文档跟没讲一样,心累整理详细流程(SDK 2.46)
    
    </summary>
    
      <category term="Android" scheme="https://github.com/December1900/December1900.github.io.git/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>不忘初心,方得始终 -- For 魅族MX5(下)</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/02/20/Meizu%20MX5-2/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/02/20/Meizu MX5-2/</id>
    <published>2016-02-19T16:00:00.000Z</published>
    <updated>2017-12-01T12:40:30.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>  「<strong>如果你没有用过Flyme4.5及之后的版本,请不要随随便便称Flyme为bugme</strong>」<a id="more"></a></p><p><img src="http://img.ithome.com/newsuploadfiles/2016/1/20160121_173019_133.png" alt="Flyme5"></p><h2 id="Flyme"><a href="#Flyme" class="headerlink" title="Flyme"></a>Flyme</h2><p>   Flyme已经更新到5.1.3.0A新春特别版,我也很愉快的度过了这个春节.<br>   关于Flyme5想了半天,觉得还是官网的介绍概括的比较准确.<br>   >这是一个更精致,更友好,更强大,更可靠的系统.</p><p>   但是Flyme 5重构了很多交互逻辑让我有点不适应,有些也不太理解.此处要手动@杨颜了.</p><h3 id="布局重构"><a href="#布局重构" class="headerlink" title="布局重构"></a>布局重构</h3><p>   Flyme 5借助mBack「轻触返回上一级菜单,按压放回主菜单」的功能优势,彻底移除底部分类导航,改为类似iOS的顶部分类导航,界面由工字型变为T字形,这也宣告着魅族彻底告别充满争议的「<strong>smartbar</strong>」.同时Flyme 5取消了有特点有个性的「<strong>侧边栏设计</strong>」,改用主流的列表和平铺设计.<br>   同时图标布局增加到五行,更好的运用大屏空间.并且加入图标批量管理功能,大大提高了桌面的管理效率.</p><p><img src="http://pic.enorth.com.cn/003/009/410/00300941037_0070dde5.png" alt="Flyme5和Flyme4.5"><br><img src="http://pic.enorth.com.cn/003/009/410/00300941038_7b510d76.png" alt="Flyme5和Flyme4.5"><br><img src="http://pic.enorth.com.cn/003/009/410/00300941041_b618c6b7.png" alt="Flyme5和Flyme4.5"></p><h3 id="色彩动画"><a href="#色彩动画" class="headerlink" title="色彩动画"></a>色彩动画</h3><p>   当时的侘寂美学已经逐渐被胭脂浓妆所替代,Flyme 5加入丰富的色彩,颜色之靓丽让我极其的不适应.同时添加大量的过渡动画和动画细节,使交互更加自然灵动.<br>   最具有代表性的就是卡片式多任务替代图标显示多任务.</p><p><img src="http://pic.enorth.com.cn/003/009/410/00300941039_e85bc95f.png" alt="Flyme5和Flyme4.5"><br><img src="http://pic.enorth.com.cn/003/009/410/00300941043_b83c2977.png" alt="Flyme5和Flyme4.5"></p><h3 id="资源整合"><a href="#资源整合" class="headerlink" title="资源整合"></a>资源整合</h3><p>   作为国内一线UI,Flyme的资源整合能力离MIUI虽然还有点差距.但是如今的魅族生态圈也在蓬勃发展,电话页新增黄页,Flyme云服务也相当完整.</p><h3 id="创新规范"><a href="#创新规范" class="headerlink" title="创新规范"></a>创新规范</h3><p>   *「<strong>mBack+悬浮球+手势唤醒</strong>」使得MX5的单手操作异常优秀,甚至可以说在5.5寸的手机中一骑绝尘.</p><ul><li><p>新增分屏模式(可惜支持分屏的应用不太多),短信加入可视化菜单和卡片式短信.</p></li><li><p>全局通知模式(当有来电时，来电提醒会以一个更轻量的通知形式出现).也不知道和4.5版本的哪个更好,全局通知模式优点不用说了,不用很突兀地切换到拨号界面,但是由于显示在屏幕顶端且不支持下拉悬停,单手体验并不好.</p></li><li><p>新春特别版的红包助手让我抢了不少红包.</p></li></ul><p><img src="http://pic.enorth.com.cn/003/009/410/00300941042_dac36470.png" alt="Flyme5和Flyme4.5"><br><img src="http://pic.enorth.com.cn/003/009/410/00300941044_028c622d.png" alt="Flyme5和Flyme4.5"></p><h1 id="续航-amp-性能-amp-发热"><a href="#续航-amp-性能-amp-发热" class="headerlink" title="#续航&amp;性能&amp;发热"></a>#续航&amp;性能&amp;发热</h1><p>   MX5配备了 3150mAH电池|联发科Helio X10.<br>   由于GPU POWER VR G6200离一线旗舰有较大的差距,导致MX5在运行大型游戏和大型网游时,掉帧明显.即使开启高性能模式,体验依然不够优秀.但是其他游戏游刃有余,日常事务配合Flyme 5,流畅的不像魅族手机.</p><p>   同样WIFI断流问题最终是落在了Helio X10这颗处理器上,联发科的高端之路啊.<br>   <a href="http://www.ithome.com/html/digi/203238.htm" target="_blank" rel="external">联发科旗舰芯片之殇：Helio X10 WiFi断流</a></p><p>   续航大幅提升,Zealer五小时续航测试剩余36%,成绩不错.对我自己来说,轻度使用一天剩余40%左右,相当感人.</p><p>   MX5支持快充技术,充满大概1时30分钟,考虑到电池容量和机身比例,速度也是很快的.也只有在充电时机身温度接近40度,平时的使用基本感受不到热度,可见功耗控制魅族提升的也不止一点半点.</p><h1 id="我想和这个世界谈谈"><a href="#我想和这个世界谈谈" class="headerlink" title="#我想和这个世界谈谈"></a>#我想和这个世界谈谈</h1><p>   魅族在2015年快速崛起,整个一年五机连发,并形成了PRO,MX,魅蓝三大完整产品线.这其中当然离不开阿里的投资,有了钱手脚自然也就放得开了,同时也离不开魅族自己的文化积淀,厚积薄发,有了可以展示的平台手脚自然也就放得开了.<br>   2015年魅族从曾经others的占有率营造了市场前三的关注度,销售额也是「<strong>350%</strong>」增长,2015年对魅族来说注定是不平凡的一年.</p><p>   但冷静下来分析,魅族也该担忧起来,销售额确实大幅增长,但80%都是魅蓝系列打下来的,魅族如今俨然成为性价比的又一代名词,后面的高端路怎么走又是一个大难题,就像Fview所说的做「好手机」不难,难的是「做好」手机.魅族也该尽快脱下自己性价比的帽子,去认真地「做好」手机.</p><p>   联想到今年微博中各种撕B,毫不客气地说为了吸引眼球魅族甚至放弃了一些节操,也不顾自己小而美的形象了.</p><p>   魅族已经不是以前的魅族了.<br>   为了大众的口味,放弃了煤油们引以为傲的小圆圈和侧边栏和种种;为了大众的口味,Flyme逐渐向原生安卓靠拢,规范设计;为了大众的口味,跟随潮流用上最先进的技术最艳丽的色彩.如今的魅族是大家的魅族.</p><p>   魅族还是以前的魅族.<br>   无论外貌怎么改变,只要灵魂不变,就不会改变,我希望魅族依然是那个最有工匠精神的魅族,依然是那个想「做好」手机的魅族.</p><p>   「为什么?」<br>   因为人们总是向往美好的事物.也希望MX6和PRO 6不要打我的脸.</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="#尾巴"></a>#尾巴</h1><p>   还记得之前黄老板对批评魅族之声的回应「<strong>不喜欢就滚</strong>」.</p><p>   做产品可不能有如此不负责的态度,我想黄老板现在也意识到了这点.</p><p>   但是产品的灵魂和图腾可不能忘了,「<strong>不喜欢就滚</strong>」应该是每代产品的烙印,每代产品独有的气质,是魅族的精神,应该是类似于一加的「<strong>不将就</strong>」.</p><p>   尽自己最大努力去做好,不喜欢的不强求.</p><p>   突然想到唠嗑的一句话「<strong>恨吧，用你的全部心思去恨吧。然而也有很多人深爱着我，理由却和恨我的人一样。</strong>」.</p><p>   有多少人爱你,就有多少人恨你.</p><p>   落到魅族头上其实就在小众清新的问题上,喜欢的人认为是侘寂美,讨厌的人认为是偏执难用.</p><p>   不用说接下来的路肯定漫长且艰难,但</p><p>   忘了初心,就丢了始终.</p><p>   大家喜欢的是有<br>   「<strong>不喜欢就滚</strong>」精神的魅族.</p><p>   <strong>利益相关</strong>:MX5,MX4,小米note,魅蓝note用户.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ROM&quot;&gt;&lt;a href=&quot;#ROM&quot; class=&quot;headerlink&quot; title=&quot;ROM&quot;&gt;&lt;/a&gt;ROM&lt;/h2&gt;&lt;p&gt;  「&lt;strong&gt;如果你没有用过Flyme4.5及之后的版本,请不要随随便便称Flyme为bugme&lt;/strong&gt;」
    
    </summary>
    
      <category term="手机测评" scheme="https://github.com/December1900/December1900.github.io.git/categories/%E6%89%8B%E6%9C%BA%E6%B5%8B%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>不忘初心,方得始终 -- For 魅族MX5(上)</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2016/02/19/Meizu%20MX5-1/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2016/02/19/Meizu MX5-1/</id>
    <published>2016-02-18T16:00:00.000Z</published>
    <updated>2017-12-01T12:40:21.610Z</updated>
    
    <content type="html"><![CDATA[<hr><p>  其实现在看来,MX5才是魅族真正变革的冒险者和领头者.</p><p>  引用Apple的一句话: 「<strong>从这里开始.</strong>」<a id="more"></a></p><p><img src="http://img1.mydrivers.com/img/20150910/b6603489a53f4b8496105da5ba88a1d5.jpg" alt="MX5-1">  </p><h1 id="相貌"><a href="#相貌" class="headerlink" title="#相貌"></a>#相貌</h1><h2 id="包装设计"><a href="#包装设计" class="headerlink" title="包装设计"></a>包装设计</h2><p>  MX5的包装依旧是承袭了MX系列的经典书页式设计,给人以精装书的即视感,简单素雅.因为成本的限制,并没有赠品,由于支持快充功能,MX5的充电头比以往的MX系列要大一圈.个人还是蛮喜欢Flyme卡针,胖乎乎的很可爱.</p><p><img src="http://image.tianjimedia.com/uploadImages/2015/182/57/JMPABBQQ20PO_2.jpg" alt="MX5-2"><br><img src="http://image.tianjimedia.com/uploadImages/2015/182/58/KTCGUWP5CJYW_3.jpg" alt="MX5-3"></p><h2 id="外观设计"><a href="#外观设计" class="headerlink" title="外观设计"></a>外观设计</h2><ul><li>整机写满了MX系列的设计语言,「素颜简单,小众侘寂」.思考了很久最终我还是用上了小众侘寂,虽然取消了个人非常喜欢的标志性「小圆圈」,而改用腰圆键,屏幕比例也从奇葩的15:9回归到大众的16:9,用上了大众的全金属,但是在安卓三大金刚键盛行以及机身同质化的今天,MX5依然称得上「小众侘寂」.</li></ul><p><img src="http://img.dgtle.com/portal/201507/14/170904uu8x8xptmtrv47xk.jpg!930px" alt="MX5-4"></p><ul><li>MX5这次的电源键+音量键手感不错,反馈适中,稍微有点松动.但是SIM卡槽松动不止一点半点,当然比魅蓝note上的突出且松动的卡槽要好上不少.这次魅族没有再采用汇顶科技的指纹方案,但是按键键程「<strong>短脆反馈差</strong>」.不得不说SIM卡槽和腰圆按键拉低了整机质感.</li></ul><p><img src="http://ww2.sinaimg.cn/large/68dbf9ebjw1etujkqt64jj21kw11xq86.jpg" alt="MX5-5"></p><ul><li>屏幕周边取消了MX4上的一片差评的「点胶悬挂技术」,转而采用类似iPhone5上的塑料包边.金属略高于屏幕,比较容易积灰.比较可惜的是前面板没有用上当下比较流行提升质感的2.5D玻璃.</li></ul><p><img src="http://www.hztalk.com/wp-content/uploads/2015/07/QQ%E5%9B%BE%E7%89%8720150712163050.jpg" alt="MX5-6"></p><ul><li>随着MX系列特有弧度的不断下降,整机更为平坦,配合着全金属,使MX5的重量只有「149g」.在5.5寸的手机中可谓相当轻薄,手感也是十分舒适.美中不足的是机身背部上下部分由于烤漆(塑料部分)比机身中部铝合金厚一些所有会有「割手感」.</li></ul><p><img src="http://upload.qudong.com/2015/1118/1447816832123.png" alt="MX5-7"></p><h1 id="屏幕"><a href="#屏幕" class="headerlink" title="#屏幕"></a>#屏幕</h1><p>  这次MX5用的是一块5.5寸FHD的AMOLED,发布会上宣称达到100%NTSC色域.AMOLED的优点就不用多说了,显示黑色不发光啊,薄啊,色域广啊等等.但是大师兄三星有这么好心,呵呵.</p><p>  MX5上的这块AMOLED最高亮度只有360nit,也就是说强光下你是看不清屏幕的.额对就是这样的,这样可以避免你走路玩手机 -_- ,不得不说确实是坑.</p><p>  而且色温大概在6500-6900K,也就是我们所说的标准白,但是在喜欢「高冷的亚洲人」眼中还是太暖了,也就是太黄了.你自己使用可能不觉得,等你看过你朋友的手机你才会觉得雾草真「黄」!!!</p><p>  三星为了保持自己的技术领先,肯定是不会把今年大受好评的AMOLED卖给魅族.知道真相的魅族还好开放了色温调整选项.在设置-「色温调整」中,每向右一格大概增加300K,两三格就差不多白了.</p><p>  同时因为<a href="https://december1900.github.io/2016/02/19/%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E5%B9%BF%E8%89%B2%E5%9F%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%A7%91%E6%99%AE/" target="_blank" rel="external">RGB PenTile排列</a>,MX5的像素密度实际上只有401*(sqrt(2/3)) = 327ppi,刚过乔老爷子的视网膜金线.</p><p>  所以对屏幕要求高的用户,还是那句话. 「<strong>无2K,不A屏.</strong>」</p><h1 id="相机"><a href="#相机" class="headerlink" title="#相机"></a>#相机</h1><p>  MX5这次依然沿用了MX4上的sensor IMX 220|新增6P镜头模组|双色温闪光灯|激光对焦.<br>  因为对相机的确没什么兴趣我就引用Zealer和Fview的结论:「白平衡不错,细节很清楚.白天的表现在2000元档很有竞争力,晚上噪点感人.」</p><h2 id="激光对焦"><a href="#激光对焦" class="headerlink" title="激光对焦"></a>激光对焦</h2><p>  激光二极管发射激光,遇到障碍物反射回来被感光器件捕捉,计算出距离后提供给镜组,然后马达直接将镜组推到合焦的位置.<br>  所以MX5对焦速度很快,且准确率高.可惜最大对焦距离只有50cm,超过之后依然只能用反差对焦.</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;  其实现在看来,MX5才是魅族真正变革的冒险者和领头者.&lt;/p&gt;
&lt;p&gt;  引用Apple的一句话: 「&lt;strong&gt;从这里开始.&lt;/strong&gt;」
    
    </summary>
    
      <category term="手机测评" scheme="https://github.com/December1900/December1900.github.io.git/categories/%E6%89%8B%E6%9C%BA%E6%B5%8B%E8%AF%84/"/>
    
    
  </entry>
  
  <entry>
    <title>手机屏幕色域的科普</title>
    <link href="https://github.com/December1900/December1900.github.io.git/2015/11/13/%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95%E5%B9%BF%E8%89%B2%E5%9F%9F%E7%9A%84%E7%A7%91%E6%99%AE/"/>
    <id>https://github.com/December1900/December1900.github.io.git/2015/11/13/手机屏幕广色域的科普/</id>
    <published>2015-11-12T16:00:00.000Z</published>
    <updated>2017-12-01T12:41:20.422Z</updated>
    
    <content type="html"><![CDATA[<p>随着今年S6那块SuperAMOLED的大受好评以及最近坊间盛传”凤”7及之后将采用AMOLED屏幕,AMOLED以及广色域屏热度一下子似乎炒了起来。<a id="more"></a></p><hr><h1 id="什么是”色域”-为什么会有这么多的”色域”"><a href="#什么是”色域”-为什么会有这么多的”色域”" class="headerlink" title="什么是”色域”?为什么会有这么多的”色域”?"></a>什么是”色域”?为什么会有这么多的”色域”?</h1><p>色域就是指由颜色构成的某个完全的子集。而人类肉眼能看到的色彩空间其实这样定义的:</p><blockquote><p>1931,CIE(国际照明委员会)制订了一套CIE1931 RGB色彩系统,规定将700nm的红,546.1nm的绿以及435.8nm的蓝作为标准三原色以他们为基础构成三角形或多边形空间,囊括它们构成的各种补色就形成了下面这张图,这基本就是人眼所能看到的所有色彩了,这货的标准名称叫做”CIE1931-xy色度图”。</p></blockquote><p> <img src="http://img.ithome.com/newsuploadfiles/2016/1/20160127_172905_921.png" alt="CIE1931-xy色度图"></p><p> 「<strong>色域越高及包含的颜色越丰富,越接近肉眼所见的真实色彩.</strong>」</p><hr><h1 id="sRGB-NTSC-Adobe-RBG色域是什么-之间有什么关系-广色域是什么"><a href="#sRGB-NTSC-Adobe-RBG色域是什么-之间有什么关系-广色域是什么" class="headerlink" title="sRGB,NTSC,Adobe RBG色域是什么?之间有什么关系?广色域是什么?"></a>sRGB,NTSC,Adobe RBG色域是什么?之间有什么关系?广色域是什么?</h1><p>简单来说[NTSC][1]色域就是美国国家电视委员会在1952年制定出来规范彩色电视显示的,而[sRBG][2]色域则是IEC和微软专门针对PC彩色显示器的,通俗叫做标准色彩空间。sRGB比NTSC色域所规定的范围要小不少,大概只有72%左右,但是72%的NTSC色域其实和sRGB并不重合,两者只是面积相当,覆盖的范围是不一样的。上张图便于理解。</p><p> <img src="http://img.poco.cn/mypoco/myphoto/20070129/3238618520070129150902040.jpg" alt="三者关系"></p><p>而随着摄影技术发展起来的Adobe RGB色域,大概涵盖约50%的肉眼可见色。因为相机的CCD和CMOS可采集到的色域已经远远超出了sRGB的范围,很多高端显示器也能做到更高色域。简而言之Adobe RGB是给高端和发烧友使用的。</p><p>其实所谓的广色域反之超过72% NTSC色域的其他所有色域,但就国际标准而言,只有色域超过了92% NTSC才能算得上广色域屏幕，三星和LG的AMOLED基本都超过了100%的NTSC色域。</p><hr><h1 id="那么当广色域屏幕遇到sRGB内容是会发生什么-两者换过来又会怎样"><a href="#那么当广色域屏幕遇到sRGB内容是会发生什么-两者换过来又会怎样" class="headerlink" title="那么当广色域屏幕遇到sRGB内容是会发生什么?两者换过来又会怎样?"></a>那么当广色域屏幕遇到sRGB内容是会发生什么?两者换过来又会怎样?</h1><p>要知道的是,目前市面上的相机和扫描仪等色彩输入设备，显示器或投影仪等色彩输出设备，以及Windows和Mac OS等操作系统的默认色域都是sRGB，网页、游戏、程序等也通通都是基于sRGB建立的。</p><p>首先sRGB和NTSC色域一样都是用CIE xy坐标体系表示的,也就是说显示最大某种颜色(例如红色)坐标的是一样的。上面也说过,NTSC色域下的最大某种颜色绝对是比sRGB下的最大某种颜色饱和度更高更艳丽。</p><p>当手机图片获取器识别出图片中的某色坐标,也告诉了手机要显示出正确的某色坐标,但是屏幕本身却并不是基于sRGB色彩空间的,而是92%的NTSC,此时屏幕应该显示个稍弱的某色。但是屏幕无法知晓这种错误,直接简单粗暴显示出92% NTSC色域下的某色,自然也就过饱和了。</p><p>「<strong>In a word,基于sRGB色域的内容在广色域屏幕上,会发生色域的放大,颜色会发生偏移,画面中的颜色饱和度都会相应提高。</strong>」</p><p>而Adobe RGB色域下的图片看起来偏黯淡是因为Adobe RGB与NTSC相对比较接近,两者差异较小,因此实际显示在屏幕上的画面色彩更接近真实场景。</p><p>所以这就是为什么在高色域屏幕(Super AMOLED)手机上看到的照片艳丽无比,但放到其他sRGB色域屏幕手机上(比如iPhone)和显示器上,照片已下载就会变得暗淡失色的原因。</p><p>从上面来看,广色域屏幕是能够让基于sRGB色彩空间的内容看起来更加艳丽,但是却牺牲了画面本身的真实性,并且现在依然有很多使用sRGB手机和显示器的用户。「<strong>因此这就是为什么同样的朋友圈照片,每个人看到东西不一样,给出的评价也不一样了。</strong>」</p><hr><h1 id="屏幕子像素的排列方式"><a href="#屏幕子像素的排列方式" class="headerlink" title="屏幕子像素的排列方式"></a>屏幕子像素的排列方式</h1><p>屏幕子像素的排列方式一般分为两种,一种是标准RGB排列方式,另一种是RGB PenTile排列方式(也就是我们常说的P排)。</p><h2 id="RGB排列"><a href="#RGB排列" class="headerlink" title="RGB排列"></a>RGB排列</h2><p>RGB排列是最标准的排列方式,它把一个方块形的像素,平均分成三等分,每一块赋予不同的颜色,这样就可以构成一个彩色像素。这也绝大多数液晶显示器以及<em>IPS</em>屏幕所采用的子像素排列方法。</p><h2 id="PenTile排列"><a href="#PenTile排列" class="headerlink" title="PenTile排列"></a>PenTile排列</h2><p>PenTile排列其实是一种OLED屏幕的像素排列方式,现在采用PenTile排列的屏幕只要为三星的AMLOED和Super AMOLED(当然还有SONY,LG)。</p><p>与标准RGB排列的像素点由红绿蓝三个子像素组成的不同,PenTile的单个像素点只有”红绿”或者”蓝绿”两个子像素点组成。我们知道只有三基色才能构成所有的颜色,所以实际显示图像时,PenTile的一个像素点会”借”用与其他相邻的像素点的另一种颜色来构成三基色。水平方向,每个像素和相邻的像素共享自己不具备的那种颜色的子像素,共同达到白色显示。</p><p>追其根本,PenTile是一种通过相邻像素公用子像素的方式,减少子像素个数,从而达到以低分辨率去模拟高分辨率的效果。</p><p>优点是屏幕的贴合层比用RGB排列IPS屏幕少,所以更艳丽,成本更低。</p><p>缺点就不言而喻了。一旦要显示精细内容的时候,清晰度远不及RGB排列的IPS屏幕;</p><p>「 <strong>而为了弥补色彩问题，所以在PenTile技术下显示色彩分割区的时候，分割线会产生两倍于实际像素点距的锯齿状纹路，也就是会产生锯齿状边缘。最后一点就是只要显示的内容不是白色，就会出现两倍于点距的网格状斑点。</strong> 」    </p><p>「 <strong>所以说，RGB PenTile技术的显示屏必须需要拥有足够高的分辨率，才可以弥补由于会产生两倍点距纹理带来的视觉效果下降。</strong> 」</p><p>也就是我们通常所说的,「<strong>无2K,不A屏.</strong>」</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着今年S6那块SuperAMOLED的大受好评以及最近坊间盛传”凤”7及之后将采用AMOLED屏幕,AMOLED以及广色域屏热度一下子似乎炒了起来。
    
    </summary>
    
      <category term="手机测评" scheme="https://github.com/December1900/December1900.github.io.git/categories/%E6%89%8B%E6%9C%BA%E6%B5%8B%E8%AF%84/"/>
    
    
  </entry>
  
</feed>
